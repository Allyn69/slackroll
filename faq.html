<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
		<title>SlackRoll Frequently Asked Questions</title>
		<style type="text/css"><!--
			body {
				background: white;
				color: black;
				font-family: sans-serif;
			}
			h1 {
				text-align: center;
				background: #006699;
				color: white;
			}
			h2 {
				background: white;
				color: #006699;
				margin-left: 5%;
				margin-right: 5%;
			}
			h3 {
				margin-left: 10%;
				margin-right: 10%;
			}
			p {
				text-align: justify;
				margin-left: 15%;
				margin-right: 15%;
			}
			ul {
				margin-left: 15%;
				margin-right: 15%;
			}
			code {
				color: red;
				background: white;
			}
			--></style>
	</head>
	<body>
		<h1>SlackRoll Frequently Asked Questions</h1>

		<h2>Current working directory</h2>

		<p><strong>Question</strong>: SlackRoll using
		the current working directory makes it very tedious
		to <em>cd</em> into the chosen directory and, if you
		forget about it, it may create directories and files
		in the wrong location. Can you change this?</p>

		<p><strong>Answer</strong>: It's a design decision,
		so you can have several package lists or mirrors with
		different configurations, making it more flexible.
		If you detect you frequently make those mistakes or
		would like to simplify the situation, you should
		consider one of the following alternatives:</p>

		<p>Putting <em>slackroll</em> inside the chosen
		directory, preventing mistakes by having to run it as
		<em>./slackroll</em>.</p>

		<p>Creating a script or shell function
		to <em>cd</em> into the chosen directory
		automatically. For example, I have the following
		lines in my superuser <em>$HOME/.bashrc</em> file:</p>

		<p><code>slackroll() { ( cd /var/slackroll &amp;&amp;
			command slackroll "$@" ); }</code></p>

		<p>Where <em>/var/slackroll</em> should be changed
		for your chosen directory.</p>

		<h2>Packages with nonstandard names</h2>

		<p><strong>Question</strong>: While attempting to setup
		SlackRoll I get "<em>Error: Nonstandard package name:
		&lt;package&gt;</em>". How can I solve this problem?</p>

		<p><strong>Answer</strong>: It seems some people are
		using packages that don't follow the Slackware package
		name convention of <em>name-version-arch-build</em>.
		I think it is wrong to have a package that doesn't
		follow the convention. SlackRoll needs to parse
		the package names to extract the different components.
		These packages make it very difficult or impossible,
		so they are rejected. There is no way to create an
		algorithm to analyze those names properly. The
		problem should be solved by removing that package,
		renaming the package archive to have a standard name
		and then installing it again.</p>

		<p>Some examples of invalid package names I have seen
		reported:</p>

		<ul>
			<li><em>pyfloppy-1.6-noarch.2AS</em>
			(Should be <em>pyfloppy-1.6-noarch-2AS</em>?)</li>

			<li><em>gammapage-0.5.i486-1AS</em>
			(Should be <em>gammapage-0.5-i486-1AS</em>?)</li>

			<li><em>scons-0.96.1-1.noarch</em>
			(Should be <em>scons-0.96.1-noarch-1</em>?)</li>
		</ul>

		<p>Remember: it doesn't matter if it's an official
		package or a foreign or custom one. It should follow
		the naming convention.</p>

		<h2>Saving the list of URLs</h2>

		<p><strong>Question</strong>: Using the <em>urls</em> or
		<em>urls-upgrades</em> operation I want to save the
		URL list to a text file. However, if I use shell
		redirections and SlackRoll prompts me to select a
		specific package version, I can't see the questions.
		Is there an easy way of doing this?</p>

		<p><strong>Answer</strong>: Yes. Pipe the output of
		SlackRoll to <code>tee url-list.txt</code> and then edit
		the file to remove the extra lines.</p>

		<h2>Coordinating with rsync</h2>

		<p><strong>Question</strong>: I normally get my remote
		packages using <em>rsync</em>, so as to keep a local copy
		of the remote tree. Can I coordinate this with SlackRoll?</p>

		<p><strong>Answer</strong>: Yes. I would use a script like
		the following one, replacing the chunks in brackets by
		the appropriate contents.</p>

		<p><code>
		SLACKROLL_DIR=<em>[path to slackroll working directory]</em><br />
		LOCAL_MIRROR_DIR=<em>[path to local copy of the tree]</em><br />
		<br />
		<em>[rsync command(s)]</em><br />
		cd $SLACKROLL_DIR<br />
		slackroll update<br />
		rm -f packages/*<br />
		for pkg in $( slackroll path-search '' | grep '\.tgz$' ); do<br />
		&nbsp;&nbsp;ln -sf $LOCAL_MIRROR_DIR/$pkg ./packages<br />
		done<br />
		</code></p>

		<p>This will synchronize your local copy of the remote tree and
		then populate the SlackRoll package cache with symbolic
		links to the package archives located inside your local copy of
		the Slackware remote tree. From the point of view of SlackRoll,
		it's like if it had already downloaded every package.</p>

		<h2>Comparing SlackRoll to other tools</h2>

		<p><strong>Question</strong>: What are the differences
		between SlackRoll and other tools like slapt-get, swaret
		or slackpkg?</p>

		<p><strong>Answer</strong>: That's a hard question
		which is better answered by exposing the features of
		SlackRoll. In any case, it should be clarified that
		you can run two types of Slackware installations. On
		the one hand you have stable releases. If you are going
		to run a stable release any tool will probably be
		useful enough for you, including SlackRoll. This is
		because stable releases are easy to manage, given that
		the only events they are exposed to are the release
		of patches. Any of the existing tools can easily
		tell you which patches have been released and let you
		automate the download and installation process. It is
		extremely rare, but not impossible, for a package to
		be added to or removed from the tree of a stable
		release.</p>

		<p>On the other hand, you can be running the testing
		tree of Slackware, also known as slackware-current.
		In this case, in my humble opinion, SlackRoll is the
		best tool. This is because SlackRoll lets you track
		almost any event happening in the testing tree, be it
		packages being added, removed or upgraded, including
		the events of a foreign package getting an official
		version and the removal of a package for which a
		customized version was installed. This is possible
		thanks to its package states foundation and the absence
		of a blacklisting mechanism in favour of working with
		two differentiated states: foreign and frozen. No other
		tool, as far as I know, can deal with as many events
		as SlackRoll. I'm unable to imagine an event that is not
		covered by SlackRoll.</p>

		<p>Apart from the type of Slackware installation you're
		running, there's the issue of using external repositories
		like the one from LinuxPackages.net. I wouldn't
		recommend using it because, in my own experience, too
		many packages from that site have been built on
		nonstandard systems. Some of them have weird dependencies
		and other ones simply won't work in your system, because
		they are submitted by people running many unofficial
		builds of official packages. I am not saying that they are
		all faulty, but the failure rate I've been getting
		is simply too high, always in my opinion. If you want
		to use these external repositories you want to run
		<strong>slapt-get</strong>, but take into account your
		resulting system can in many cases not be considered Slackware
		anymore, due to the high number of unofficial builds
		you will be running. It will be something close to
		Slackware. A customized Slackware if you prefer.</p>

		<p>If you are not going to use external repositories,
		or packages from those external repositories are the
		exception in your system, the dependency mechanism of
		<em>slapt-get</em> is useless, and you may well be
		runing SlackRoll, which tracks more events. Another
		point of failure in <em>slapt-get</em> is that it uses
		a version comparisson algorithm to decide if a package
		should be upgraded or not. It can fail and, more
		commonly, it fails to detect package reverts,
		which happen from time to time in slackware-current,
		forcing you to pay a lot of attention to the change log.</p>

		<p>Compared to the shell-based <strong>swaret</strong>
		(there's a new <em>swaret</em> being developed in Perl),
		SlackRoll lacks tracking binary dependencies, but it
		compensates that lack by letting you query the Slackware
		Package Browser from the command line comfortably. Apart
		from that, <em>swaret</em> is incredibly slow and CPU
		hungry even when it's only downloading files from the
		network, and doesn't come close to tracking as many
		events as SlackRoll. SlackRoll is, in my humble opinion,
		a clear winner over <em>swaret</em> unless you absolutely
		love the binary dependency resolution it provides. For
		me that's a minor feature. The Perl implementation is
		supposed to be basically the same, but solving the high
		CPU usage problem. If that's the case, SlackRoll would
		still be a much better option, in my opinion, because
		<em>swaret</em> still doesn't do <em>glibc</em> upgrades
		properly, does not detect removed packages, etc.</p>

		<p>SlackRoll's closest friend is <strong>slackpkg</strong>,
		included in the <em>/extra/</em> tree. You can think of it
		like a very much improved <em>slackpkg</em> that works
		faster, detects more corner cases and has more features.
		If you run <em>slackpkg</em>, do not hesitate to give
		SlackRoll a try.</p>

		<p>Finally, in general, SlackRoll is at least as fast or
		faster than any of the above tools, specially faster than the
		ones that are big shell scripts (slackpkg and swaret). It
		downloads less metadata than any other, because it only needs
		FILELIST.TXT and, for convenience, the new entries from the
		change log (indeed, it only downloads the new entries). It
		detects more events, which is specially useful when running
		slackware-current. And it has some useful features no other
		tool has, like the operations to detect orphan files and
		broken symlinks. You won't have to run <em>grep</em> on the
		contents of <em>/var/log/packages</em> anymore, because it
		has a local search operation, and also a remote search
		operation that lets you query the Slackware Package Browser
		comfortably from the command line and receive the results
		on your terminal. And it also lets you choose which package
		version to install when there are several ones available. It
		lets you upgrade individual packages or every upgradeable
		package, install new packages, remove old ones, search for
		package names or packages with a given tree component, list
		alternative versions of packages, detect and warn you about
		activity in <em>glibc</em> packages (giving them priority
		while upgrading too), etc.</p>

	</body>
</html>
