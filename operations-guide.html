<html>
<head>
<title>slackroll: Operations Guide</title>
<link rel="stylesheet" href="slackroll.css" type="text/css" />
</head>
<body>

<div class="title">slackroll</div>
<div class="subtitle">Operations Guide</div>

	<h1>General Concepts</h1>

	<p>When the program needs to run GnuPG, it first checks for <code>gpg2</code> and then <code>gpg</code>, and uses whichever is found first.</p>

	<p>Every operation that needs to download packages will always check first if the packages are present in the package cache (<code>/var/slackroll/packages</code>).  This means that if you download packages using an external tool like <code>wget</code> or <code>rsync</code> and want the program to pick them up during the upgrade process, you only need to copy them to, or link them in, the package cache. Note that the package cache stores packages in a flat hierarchy. There is a <span class="caps">FAQ</span> entry on creating symbolic links to a local copy of the mirror.</p>

	<p>Every operation that has to run <code>/sbin/upgradepkg</code> to install or upgrade packages follows the same internal mechanism. Once it has been clarified which packages are to be downloaded, the program proceeds and, for each one of them, it checks if the package exists in the package cache or not. If it does not exist, it is downloaded and stored in the package cache. Once every package is in the package cache, the program calls <code>upgradepkg</code> on each one, always (even if the package is already installed in your system). Finally, the program reviews pairs of <code>.new</code> files, in two steps. In the first step the program gets the list of <code>.new</code> files present in the packages it ran <code>upgradepkg</code> on, and reviews them. Later, we will explain this review process in detail. Second, it gives you the opportunity of removing legacy <code>.new</code> files. This means that the program, before running <code>upgradepkg</code>, had retrieved a list of <code>.new</code> files from the locally installed versions of those packages, if they existed. Once the packages are installed and after reviewing the <code>.new</code> files, it can see if there was any <code>.new</code> file present in the old packages which is not present in the installed packages. Usually, <code>upgradepkg</code> will remove these <code>.new</code> files, but not their counterparts without <code>.new</code> suffix. The program will ask if you want to remove them.</p>

	<p>Every operation that needs to run <code>upgradepkg</code> on a set of packages that are not provided explicitly by the user in a given order (like the <code>upgrade</code> operation as opposed to <code>install</code>) will proceed in alphabetical order, except for the packages <code>glibc-solibs</code>, <code>sed</code> and <code>pkgtools</code>, which will be prioritized and put in the top of the list to prevent silly mistakes that may render your system unusable.</p>

	<p>Reviewing <code>.new</code> file pairs is easy. They are pairs because each <code>.new</code> file has a counterpart without the <code>.new</code> suffix. The program will offer you a set of repeating options for each pair. One option which is always available is the one to review the next pair. This is the only mechanism to start reviewing the next pair. If you choose any of the other operations, when it&#8217;s finished you will continue to be asked about the same pair. This has the purpose of letting you run several operations for each pair. If no file of the pair is found, the only option will be to review the next pair, yet you are still notified that both files were missing.  If only one of them is found, you will be given the opportunity of editing it with the editor indicated in the <span class="caps">VISUAL</span> environment variable (see <code>/etc/profile</code> for this) or <code>vim</code> by default. If the two files are found, you can edit both at the same time using <code>vimdiff</code>. This option lets you view the file differences and perform several actions. If the old configuration file is valid, you can decide not to touch the <code>.new</code> file and keep using the old file.  If the configuration needs to be ported to the new file, this is the best option to do it. Note that <code>vimdiff</code> uses colors to highlight file differences.  These colors may interfere with the syntax highlighting color and render text invisible or hard to read. It is recommended to disable syntax highlighting when running <code>vimdiff</code> (<code>:syntax off</code>). In case both files exist you can also remove the <code>.new</code> file (useful when the old configuration file is still valid) or move the <code>.new</code> file overwriting the old file (useful after having ported the configuration to the <code>.new</code> file).</p>

	<h1>Operations</h1>

	<h2>help</h2>

	<p>This operation prints a help text with a summary of the available operations.</p>

	<h2>version</h2>

	<p>This operations prints the program version to standard output.</p>

	<h2>print-mirror</h2>

	<p>This operation prints the current mirror <span class="caps">URL</span> to standard output.</p>

	<h2>set-mirror</h2>

	<p>This operation sets the mirror <span class="caps">URL</span> to the one you specify as its argument.</p>

	<h2>print-primary-mirror</h2>

	<p>This operation prints the current primary mirror <span class="caps">URL</span> to standard output.</p>

	<h2>set-primary-mirror</h2>

	<p>This operation sets the primary mirror <span class="caps">URL</span> to the one you specify as its argument. You should avoid changing the primary mirror <span class="caps">URL</span>. It is used to download the package signatures and <span class="caps">GPG</span> key files among others. This behavior is intended to protect you from trivial attacks coming from evil mirrors, and it may also let you know when your mirror is not up to date, due to package signatures failing to download.</p>

	<h2>update</h2>

	<p>This operation downloads the new change log entries if they exist and stores them in your hard drive. After that, it downloads the list of files from the file <code>FILELIST.TXT</code> and stores it in <code>/var/slackroll</code>. Both actions take into account the selected mirror.</p>

	<h2>import-key</h2>

	<p>This operation downloads the file <code>GPG-KEY</code> from the mirror and runs either <code>gpg2</code> or <code>gpg</code>, whichever finds first with the option <code>--import-key</code> and that file. After importing the key, the file <code>GPG-KEY</code> is removed and does not remain on disk.</p>

	<h2>changelog</h2>

	<p>This operation prints on screen the last downloaded batch of changelog entries.</p>

	<h2>download-changelog</h2>

	<p>This operation downloads the full <code>ChangeLog.txt</code> file from the mirror and stores it in your hard drive, rebuilding the internal changelog database and creating a new one with the downloaded contents. Normally it&#8217;s not needed, but it could be useful if, for example, you accumulate a lot of entries over several years and want to discard all the old ones belonging to previous stable versions.</p>

	<h2>list-changelog</h2>

	<p>This operation prints a list of changelog entries from the local database, indicating their identifiers and timestamps.</p>

	<h2>changelog-entries</h2>

	<p>This operation, given a list of changelog entry identifiers (that you can get by running the <code>list-changelog</code> operation), will print them on screen in the specified order.</p>

	<h2>full-changelog</h2>

	<p>This operation prints every known changelog entry.</p>

	<h2>upgrade</h2>

	<p>This operation will check which packages are in the state <span class="caps">OUTDATED</span> and which remote versions exist for them. If, for any package, more than one remote version is available, it will prompt you to choose one of them to be downloaded. The local version will also be printed above the choice text because it may give clues about the right choice. Once it has fully determined which packages need to be downloaded, it will proceed to download them, in alphabetical order except for the packages <code>glibc-solibs</code>, <code>sed</code> and <code>pkgtools</code>, which will be downloaded first if they are <span class="caps">OUTDATED</span>. If any package to be downloaded already exists in the package cache, it will not be downloaded. Once all selected packages are present in the package cache, they will be installed running <code>/sbin/upgradepkg</code> in the same order as mentioned above. The program will print a warning and ask for confirmation if you try to perform this operation while there are packages in the state <span class="caps">NEW</span>. This is because the correct order in most cases is to install new packages first, before upgrading the outdated ones. An outdated package may depend on one which was added. Sometimes there is no danger in running this operation before installing new packages, and maybe in exceptional cases it will be wrong to install new packages first. The changelog should contain information to clarify the correct order.</p>

	<h2>upgrade-key-packages</h2>

	<p>This operation is similar to the <code>upgrade</code> operation, but it will only affect the key packages, which are <code>glibc-solibs</code>, <code>sed</code> and <code>pkgtools</code>.  No warning will be printed while running this operation, as only in very special cases doing this operation before any other poses a danger.  Again, the changelog should contain information to clarify the correct order.</p>

	<h2>download-upgrades</h2>

	<p>This operation is similar to the <code>upgrade</code> operation, but the files will only be downloaded. As no <code>upgradepkg</code> command is run, no <code>.new</code> files are reviewed.</p>

	<h2>download-key-packages</h2>

	<p>This operation is similar to <code>download-upgrades</code> but restricting the operation to the <span class="caps">OUTDATED</span> key system packages (<code>glibc-solibs</code>, <code>sed</code> and <code>pkgtools</code>).</p>

	<h2>urls-upgrades</h2>

	<p>This operation is similar to <code>download-upgrades</code> but only printing the URLs and total size of the packages. This option is mostly useful to view the total download size and getting a list of URLs to be used with an external download manager, instead of the program&#8217;s simple downloading routine.</p>

	<h2>urls-key-packages</h2>

	<p>This operation is similar to <code>urls-upgrades</code>, but limiting the output to the key system packages (<code>glibc-solibs</code>, <code>sed</code> and <code>pkgtools</code>).</p>

	<h2>kernel-upgrade</h2>

	<p>Upgrades kernel packages but uses <code>installpkg</code> instead of <code>upgradepkg</code>. This way, previous packages are not removed from the system while the new kernel is tested to work.</p>

	<h2>kernel-clean</h2>

	<p>Removes kernel package versions not present in the remote tree. This can be used after rebooting to a new kernel, once it has been verified it works properly, to remove the previous kernel packages.</p>

	<h2>clean-cache</h2>

	<p>This operation will check the files present in the package cache. If any of them belongs to a package or package version not present in the remote tree, it will be deleted. It should be run from time to time to prevent the package cache from growing too much and keep it with the same contents as the remote mirror. It must be noted that this operation does not remove every package in the package cache (<code>slackroll erase-cache</code> will do that). After an upgrade, you may want to confirm everything is running properly before running this operation, so as to keep the previous package versions in case a problem arises with the new packages.</p>

	<h2>erase-cache</h2>

	<p>This operation will remove every file from the package cache, without asking questions, so it should be used with care.</p>

	<h2>erase-tmp</h2>

	<p>This operation will remove every file from the &#8220;tmp&#8221; directory. This is <code>/var/slackroll/tmp</code> by default. It can be changed to something else setting the environment variable <span class="caps">TMPDIR</span>, but it&#8217;s not recommended to run this operation if you set <span class="caps">TMPDIR</span>. This operation is intended to remove partial download leftovers if the program is interrupted while downloading something. It will not ask questions. Normally, you shouldn&#8217;t need it.</p>

	<h2>erase-all</h2>

	<p>This operation is the equivalent of <code>erase-cache</code> and <code>erase-tmp</code> combined. Again, it will not ask questions.</p>

	<h2>touch</h2>

	<p>This operation forces the program to update the persistent database and package states. Normally it shouldn&#8217;t be needed. It&#8217;s there for testing and debugging purposes.</p>

	<h2>list-transient</h2>

	<p>This operation prints a list of packages in transient (temporary) states (<span class="caps">NEW</span>, <span class="caps">OUTDATED</span>, <span class="caps">UNAVAILABLE</span>). It can be used as a summary of activity and its output should be empty once the upgrade work is finished. It also prints a big warning if it detects activity in key system packages (<code>glibc-solibs</code>, <code>sed</code> and <code>pkgtools</code>).</p>

	<h2>list-upgrades</h2>

	<p>This operation will print a list of packages with pending upgrades (state <span class="caps">OUTDATED</span>). For each one of them, the local and available remote versions are printed. Like <code>list-transient</code>, it will print a big warning if it detects activity in key packages.</p>

	<h2>list-outdated-frozen</h2>

	<p>This operation prints the list of <span class="caps">FROZEN</span> packages that the program would consider <span class="caps">OUTDATED</span> otherwise. As the frozen state is normally used to prevent the program from upgrading a specific subset of packages automatically, this operation can be used to determine when a manual upgrade of those packages is needed.</p>

	<h2>list-alternatives</h2>

	<p>This operation will print a list of packages for which several versions are available, between local and remote versions. The usefulness of this operation is not clear, but it was included for testing and debugging purposes.</p>

	<h2>list-versions</h2>

	<p>Receiving a list of package names as arguments, this operation will list the local and remote versions of each one of them, in the same format as <code>list-upgrades</code>.</p>

	<h2>state</h2>

	<p>Receiving a list of package names as arguments, this operation will print the state of every one of them.</p>

	<h2>list-new</h2>

	<p>This operation lists the names of <span class="caps">NEW</span> packages, in alphabetical order with key system packages first (should they be in the <span class="caps">NEW</span> state for some weird reason).</p>

	<h2>list-unavailable, list-installed, list-not-installed, list-frozen, list-foreign and list-outdated</h2>

	<p>These operations are similar to <code>list-new</code> for the different states.</p>

	<h2>list-local</h2>

	<p>This operation is similar to <code>list-new</code> but listing the packages that are in the local system (<span class="caps">OUTDATED</span>, <span class="caps">UNAVAILABLE</span>, <span class="caps">INSTALLED</span>, <span class="caps">FROZEN</span>, <span class="caps">FOREIGN</span>).</p>

	<h2>list-remote</h2>

	<p>This operation is similar to <code>list-new</code> but listing all packages present in the remote tree.</p>

	<h2>list-all</h2>

	<p>Similar to <code>list-new</code> but printing every known package.</p>

	<h2>new-not-installed</h2>

	<p>This operation marks as <span class="caps">NOT</span> <span class="caps">INSTALLED</span> every package in the state <span class="caps">NEW</span>.</p>

	<h2>unavailable-foreign</h2>

	<p>This operation marks as <span class="caps">FOREIGN</span> every package in the state <span class="caps">UNAVAILABLE</span>.</p>

	<h2>new</h2>

	<p>Receiving a list of package names as its arguments, this operation marks them as <span class="caps">NEW</span>. Only packages in the states <span class="caps">NEW</span> and <span class="caps">NOT</span> <span class="caps">INSTALLED</span> can be marked as <span class="caps">NEW</span>.</p>

	<h2>unavailable</h2>

	<p>Similar to <code>new</code> with the state <span class="caps">UNAVAILABLE</span>. Only packages in the states <span class="caps">UNAVAILABLE</span> and <span class="caps">FOREIGN</span> can be marked as <span class="caps">UNAVAILABLE</span>.</p>

	<h2>installed or unfreeze</h2>

	<p>Similar to <code>new</code> with the state <span class="caps">INSTALLED</span>. Only packages in the states <span class="caps">INSTALLED</span> and <span class="caps">FROZEN</span> can be marked as <span class="caps">INSTALLED</span>.</p>

	<h2>not-installed</h2>

	<p>Similar to <code>new</code> with the state <span class="caps">NOT</span> <span class="caps">INSTALLED</span>. Only packages in the states <span class="caps">NOT</span> <span class="caps">INSTALLED</span> and <span class="caps">NEW</span> can be marked as <span class="caps">NOT</span> <span class="caps">INSTALLED</span>.</p>

	<h2>frozen or freeze</h2>

	<p>Similar to <code>new</code> with the state <span class="caps">FROZEN</span>. Only packages in the states <span class="caps">FROZEN</span>, <span class="caps">OUTDATED</span> and <span class="caps">INSTALLED</span> can be marked as <span class="caps">FROZEN</span>.</p>

	<h2>foreign</h2>

	<p>Similar to <code>new</code> with the state <span class="caps">FOREIGN</span>. Only packages in the states <span class="caps">FOREIGN</span> and <span class="caps">UNAVAILABLE</span> can be marked as <span class="caps">FOREIGN</span>.</p>

	<h2>install</h2>

	<p>This is one of the most complex operations. Its arguments are a list of package names in the simple case, but it admits specific package versions as its arguments too. A specific package version has the form <em>name-version-arch-build.tgz</em> and an optional path prefix. This allows you to copy and paste a specific package version from the output of other commands to use it as one argument to this operation. Simply put, we could say that the <code>upgrade</code> operation is a special case of this one, using the outdated packages as implicit arguments. The exact outcome of this operation depends on the specific package and other external circumstances. It is important to note that packages are processed in the order you indicate in the command line. They are not sorted. Its main purpose is to both install and upgrade a specific package list. As <code>upgrade</code>, packages are downloaded first if needed, passed to <code>upgradepkg</code> and <code>.new</code> file pairs are reviewed. If the package is not present in the system, it will be installed. If it is present, it will be upgraded. If the local version and the one you are installing match, <code>upgradepkg</code> will do nothing, but the procedure will continue and <code>.new</code> files will be reviewed. This gives the operation a good amount of flexibility as you can use it also to review <code>.new</code> files from specific packages. If key system packages are outdated and you do not include any of them as arguments, the program will print a warning as you may be violating the correct operation order, installing a package that depends on the new version of <code>glibc-solibs</code>, for example, and rendering your system useless. In some very special cases, you may really need to run this operation first. Again, the changelog should provide information about the correct order.</p>

	<h2>install-new</h2>

	<p>This operation is like <code>install</code> using the <span class="caps">NEW</span> packages as implicit arguments.</p>

	<h2>install-path</h2>

	<p>This operation is similar to <code>install</code>. Its arguments are a list of Python regular expressions (similar to <code>grep</code> or Perl regular expressions in the most common cases). The implicit <code>install</code> arguments would be packages with a path that matches any of the indicated expressions.</p>

	<h2>install-foreign</h2>

	<p>This operation takes a list of package files present in the file system.  It will install or upgrade those packages and mark them as <span class="caps">FOREIGN</span>, and will also review <code>.new</code> file pairs. It is intended to be a comfortable way of installing foreign packages.</p>

	<h2>reinstall</h2>

	<p>This operation is similar to <code>install</code>, but <code>upgradepkg</code> will be called with the <code>--reinstall</code> option.</p>

	<h2>replace</h2>

	<p>This operation receives two package names. The first one must be an unavailable package and the second one a new package. The program will call <code>upgradepkg</code> using the &#8220;% notation&#8221; to upgrade the unavailable package using the new one.  This should be useful with <code>slackware-current</code> in the case of a package name change, but there may be other cases in which it could be useful. See for example the changelog entry from <em>Tue Apr  1 02:41:32 <span class="caps">CDT</span> 2008</em> about the change from <code>util-linux</code> to <code>util-linux-ng</code>.</p>

	<h2>download, download-new and download-path</h2>

	<p>These operations are all similar to <code>download-upgrades</code>, and relate to their <code>install</code> counterparts in the same way <code>upgrade</code> relates to <code>install</code>.</p>

	<h2>info</h2>

	<p>This operation receives a list of arguments with the same flexibility as the <code>install</code> operation. However, instead of proceeding with the normal routine, it displays the package information. This information is taken from the files in <code>/var/log/packages</code> if it exists there, or downloaded from the small info files for every package in the remote tree. These small files have less information than the local info files, but give a package description and can be downloaded quickly.</p>

	<h2>info-new and info-path</h2>

	<p>These operations relate to <code>info</code> in the same way <code>install-new</code> and <code>install-path</code> relate to <code>install</code>.</p>

	<h2>local-info</h2>

	<p>This operations receives a list of local package names and prints all the information available for them under <code>/var/log/packages</code>, including the full file list.</p>

	<h2>urls, urls-new and urls-path</h2>

	<p>These operations are similar to <code>urls-upgrades</code>, and relate to their <code>install</code> counterparts in the same way <code>upgrade</code> relates to <code>install</code>.</p>

	<h2>remove</h2>

	<p>This operation takes a list of package names as its arguments and calls <code>removepkg</code> on the local versions of those packages. In addition, it will give you the opportunity of removing <code>.new</code> file pairs left behind, which is the only advantage over calling <code>removepkg</code> directly.  This operation will generate a warning when run while there are <span class="caps">NEW</span> or <span class="caps">OUTDATED</span> packages, as you may then be breaking the correct order of operations. In some cases this may pose no danger or even be the correct order. As always, the changelog should contain information about the correct order of operations.</p>

	<h2>remove-unavailable and remove-path</h2>

	<p>These operations are similar to <code>remove</code>. The first one is like calling <code>remove</code> with an implicit argument list formed by the packages in state <span class="caps">UNAVAILABLE</span>. The second one is like using an implicit argument list formed by packages with a path matching any of the Python regular expressions used as arguments. It must be noted that this second operation only searches packages present in the remote list.</p>

	<h2>remote-paths</h2>

	<p>This operation prints a plain list of all the remote packages, including the <code>tgz</code> suffix and their relative paths.</p>

	<h2>print-blacklist</h2>

	<p>This operation prints the list of blacklisted regular expressions, preceded by their expression index. When <code>slackroll</code> creates the list of remote packages, their full names, including their relative paths, are checked against the expressions in the blacklist. If a match is found, the package file is ignored and not included in the list of remote packages, as if it did not exist. This can be used for many purposes, but the intended usage is to discard specific package versions that are known not to be interesting. For example, if a user has the <span class="caps">SMP</span> kernel package and headers installed, and the headers package is upgraded, they know they are not interested in the kernel headers package from <code>/extra/linux-&#60;something&#62;-nosmp-sdk/</code>. They can blacklist that version so they are not asked about which one they prefer every time the package is upgraded.</p>

	<h2>blacklist-add</h2>

	<p>This operation adds Python regular expressions to the blacklist.</p>

	<h2>blacklist-del</h2>

	<p>This operation removes expressions from the blacklist, specifying one or more expression indexes as its arguments.</p>

	<h2>update-manifest</h2>

	<p>This operation downloads every <span class="caps">MANIFEST</span>.bz2 file from the Slackware mirror and creates a database with their contents. This manifest database can be used to find out which package or packages contain specific files. Downloading and processing the <span class="caps">MANIFEST</span>.bz2 files does not take too long but it could take a bit of time. This is why these files are not downloaded and processed during the <code>update</code> operation. Searching the Slackware Package Browser or using the <code>local-search</code> operation is usually faster, but this operation and the <code>manifest-search</code> operation are provided as a fallback mechanism. For accurate results, update the manifest database before starting to search for files, so the database reflects an up-to-date remote tree.</p>

	<h2>search-manifest</h2>

	<p>This operation receives a list of Python regular expressions and uses them to search for matching files in the manifest database. For it to work, you need to have a manifest database built with the <code>update-manifest</code> operation.</p>

	<h2>pb-search or remote-search</h2>

	<p>This operation connects to the Slackware Package Browser and searches for the files specified as arguments, printing the search results on the screen. It is important to note that the names are automatically quoted for ease of use, and that you should visit the Slackware Package Browser page to learn more about how it can be used. The Slackware version used to search will be extracted from the mirror <span class="caps">URL</span>.</p>

	<h2>local-search</h2>

	<p>This operation receives a list of Python regular expressions and searches for files with patches that match any of them. This is equivalent to running <code>grep</code> on the contents of <code>/var/log/packages</code>, but the regular expressions are more powerful, the paths are considered to have a leading slash and the info file headers will be ignored, preventing false positives.</p>

	<h2>name-search</h2>

	<p>This operation will print the list of package and package states for packages with a name that matches any of the Python regular expressions indicated as arguments.</p>

	<h2>path-search</h2>

	<p>This operation will print the list of remote packages with a path that matches any of the Python regular expressions indicated as arguments.</p>

	<h2>orphan-search</h2>

	<p>This operation will examine the full hierarchy below the indicated paths searching for files that do not appear in the info files from <code>/var/log/packages</code>. This operation may be very time consuming, and the results should always be interpreted carefully. It is not safe to remove every file reported by the output of this command, as many important system files do not belong to any package, like <code>/etc/fstab</code>. If interpreted carefully, however, it may be run once in a blue moon and may help keeping the system clean of files left behind by some packages, contributing to a manageable system in the long run.</p>

	<h2>broken-symlinks</h2>

	<p>This operation will examine the full hierarchy below the specified paths searching for broken symlinks. It may be a slow operation, and some of the broken symlinks it finds may be useful if specific packages are installed, so results should be interpreted carefully.</p>

	<h2>missing-search</h2>

	<p>This operation takes every file from the information in <code>/var/log/packages</code> and checks if it&#8217;s present in your system. It may take a long time to complete, and there are a few known files which always appear in the results, so they should be interpreted carefully.  In general, it may indicate damaged packages that need to be reinstalled. Take into account results from <code>/install</code>, <code>/dev</code> and <code>/lib/incoming</code> are ignored in order to avoid an unreadable output with too much noise.</p>
</body>
</html>
