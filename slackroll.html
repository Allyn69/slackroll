<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
		<title>SlackRoll: Manage a Slackware system</title>
		<style type="text/css"><!--
			body {
				background: white;
				color: black;
				font-family: sans-serif;
			}
			h1 {
				text-align: center;
				background: #006699;
				color: white;
			}
			h2 {
				background: white;
				color: #006699;
				margin-left: 5%;
				margin-right: 5%;
			}
			h3 {
				margin-left: 10%;
				margin-right: 10%;
			}
			p {
				text-align: justify;
				margin-left: 15%;
				margin-right: 15%;
			}
			dl {
				text-align: justify;
				margin-left: 15%;
				margin-right: 15%;
			}
			dt {
				font-weight: bold;
				margin-top: 1ex;
				margin-bottom: 1ex;
			}
			code {
				color: red;
				background: white;
			}
			#index {
				padding: 1ex 1ex 1ex 1ex;
				color: white;
				background-color: #009966;
				text-align: center;
				font-size: small;
			}
			#index li {
				display: inline;
				margin-left: 2ex;
				margin-right: 2ex;
			}
			#index li a {
				font-weight: bold;
				color: white;
				background-color: #009966;
			}
			--></style>
	</head>
	<body>
		<h1>SlackRoll: Manage a Slackware system</h1>

		<ul id="index">
			<li><a href="#target_audience">Target&nbsp;audience</a></li>
			<li><a href="#before_start">Before&nbsp;you&nbsp;start</a></li>
			<li><a href="#get">Get&nbsp;SlackRoll</a></li>
			<li><a href="#getting_started">Getting&nbsp;started</a></li>
			<li><a href="#normal_operation">Normal&nbsp;operation</a></li>
			<li><a href="#feedback">Feedback</a></li>
		</ul>

		<h2><a name="target_audience" />Target audience</h2>

		<p><strong>slackroll</strong> is a package or update manager
		for Slackware systems. It does not provide dependency
		checking and uses <strong>pkgtools</strong> to install or
		upgrade packages. It's designed to work with official
		mirrors. If you have a Slackware system mainly
		composed of official packages and a handful of
		unofficial packages, <strong>slackroll</strong>
		can help you manage it and keep in touch with the remote
		tree. It tries to know when new packages appear, when
		packages are removed and when packages are upgraded.</p>

		<h2><a name="before_start" />Before you start</h2>

		<p>So you have decided to try <strong>slackroll</strong>. Let
		me introduce a few concepts so you don't get lost.</p>

		<p><strong>slackroll</strong> works with the current directory.
		It doesn't work with a fixed system directory like, let's say,
		<code>/var/slackroll</code>. You can use
		<code>/var/slackroll</code> if you want. You have to choose
		a directory and <code>cd</code> to it before running the
		program. Want to use something inside <code>/var</code>?
		Inside <code>/root</code>? Inside <code>/media</code>?
		Whatever floats your boat.</p>

		<p>In the following text I'm going to be talking about packages.
		For package, we are going to understand a named piece of
		software, without having any specific version unless I
		explicitly mention it. A package can be <em>bash</em> or
		<em>kdewebdev</em> or <em>gcc-gfortran</em>, for example.</p>

		<p>Each package is in one of several possible states. The
		program tries to keep a persistent "database" that associates
		each package with its state. When it runs, it analyzes the list
		of packages present in your system, the list of remote packages,
		and tries to keep the persistent database updated by introducing
		new entries, deleting old ones and changing the state of some
		of those entries.</p>

		<h3>States to avoid</h3>

		<dl>

		<dt>NEW</dt> <dd>A package is in this state when it's
		present in the remote tree and it wasn't present before.
		If you detect you have packages in this state you should
		decide if you want to install them or mark them as not
		installed. This state lets you see which packages are being
		added to the remote tree.</dd>

		<dt>UNAVAILABLE</dt> <dd>Sorry if this name is
		somehow confusing. A package is in this state when it's
		present in your system, but not in the remote tree. You
		should decide if you want to remove them from your system
		or mark them as foreign packages. This state lets you
		see which packages are being removed from the remote
		tree.</dd>

		<dt>OUTDATED</dt> <dd>A package is outdated if it's
		present in your system and in the remote tree, but
		the local version does not match any relevant one in
		the remote tree. The program will try to upgrade
		these packages.</dd>

		</dl>

		<h3>Normal states</h3>

		<dl>

		<dt>INSTALLED</dt> <dd>A package is installed if it's
		present in your system and in the remote tree, and
		the local version is not outdated. Very common state,
		as you can suppose.</dd>

		<dt>NOT INSTALLED</dt> <dd>A package is not
		installed if it's a known package which is not present
		in your system but exists in the remote tree. It's also
		a very common state.</dd>

		<dt>FROZEN</dt> <dd>No package will enter the frozen state
		unless you mark it so. It should be used for packages
		present in your system and in the remote tree, but that
		you don't want to upgrade automatically.  This state can
		be used for packages which are not meant to be upgraded
		automatically or ever, like <em>aaa_elflibs</em> and others,
		and probably for customized versions of official packages. For
		example, my custom build of <em>freetype</em> is marked as
		frozen. You must pay attention to these packages, as upgrades
		to them will be silently ignored. You may find the
		<em>list-versions</em> and <em>list-outdated-frozen</em>
		operations useful to detect version mismatches between your
		local copy and the ones in the remote tree. Having a package
		in the frozen state does not prevent you from using the
		<em>install</em> operation to download and install a
		different version. If the package ever disappears from
		the remote tree, it will be marked as unavailable and
		you will probably see it. You could continue to use it
		by marking it as foreign if you wish.</dd>

		<dt>FOREIGN</dt> <dd>No package will enter the foreign
		state unless you mark it so. It should be used for
		packages that do not exist in the remote tree but that,
		unlike unavailable packages, are present in your system
		on purpose.  For example, the <em>mplayer</em> package
		in my system is marked as foreign. A foreign package will
		be marked as installed or outdated if it ever appears in
		the remote tree, becoming a candidate for upgrading.
		Hopefully, you'll notice this fact. You could still use
		your own version instead of the remote (official) one by
		marking it as frozen.</dd>

		</dl>

		<h2><a name="get" />Get SlackRoll</h2>

		<p><a href="http://sourceforge.net/project/showfiles.php?group_id=197236">slackroll</a>
		is a self-contained Python script released to the public
		domain. Drop it somewhere like <code>/usr/local/sbin</code>
		or <code>/usr/local/bin</code>, give it execution permissions
		and you will be ready. The available tarball contains the
		program alone. Initially I uploaded the file directly,
		but the SourceForge release system didn't let me use the
		same filename again, so I opted for a simple tarball with
		the version number in its name. If you'd prefer another
		distribution method just drop me an email message.</p>

		<h2><a name="getting_started" />Getting started</h2>

		<p><strong>slackroll</strong> requires <em>python</em>,
		<em>pkgtools</em>, <em>gnupg (or gnupg2)</em>, <em>vim</em> and a
		pager (<em>less</em> by default) to operate properly.</p>

		<p>It should be noted that you can start using
		<strong>slackroll</strong> whenever you want, but my advice
		is to do it when your system is under control and there
		are no upgrades pending. This will give you a chance
		of configuring the program and setting the package states
		properly without making serious mistakes.</p>

		<p>You should first choose a working directory and a
		Slackware mirror. Take into account
		<strong>slackroll</strong> will store downloaded
		packages in a subdirectory of the chosen one, so you will
		probably need to have a good amount of space available for
		them in there. Create the directory, change to it and
		echo the mirror name to a file named <em>mirror</em>.</p>

		<p><code>echo 'http://slackware.osuosl.org/slackware-current/'
			&gt;mirror</code></p>

		<p><strong>Do not forget the trailing slash!</strong>
		Great. You are ready to start. Retrieve the remote GPG
		key from the mirror to add it to your keyring. Having the
		GPG key is required, and it's safe to do this step even
		if the key is already in your keyring, supposing you trust
		the mirror you chose. If you don't, get the GPG key by
		other means and add it to your keyring, skipping this
		step.</p>

		<p><code>slackroll import-key</code></p>

		<p>Retrieve information about the remote packages. You'll have
		to perform this step every time Patrick Volkerding changes the
		remote tree.</p>

		<p><code>slackroll update</code></p>

		<p>Finally, you could start checking if there are new packages,
		unavailable packages or upgrades. However, the first time you
		use <strong>slackroll</strong>, any package not installed in
		your system will be marked as new, every foreign package will
		be marked as unavailable, and every customized package will
		probably be a candidate for upgrading if you try to do so.
		If you have your system under control (and I hope you do!),
		you can in most cases blindly mark all new packages as not
		installed. There's a command to do it, being a common first
		operation.</p>

		<p><code>slackroll new-not-installed</code></p>

		<p>In most cases, you can also mark any unavailable packages as
		foreign. However, the number of foreign packages is usually
		quite low, and forgetting to uninstall a package which has been
		removed is a very common mistake, so my advice is to review
		the list of unavailable packages by hand, detecting which
		ones may not be foreign packages and need to be uninstalled.</p>

		<p><code>slackroll list-unavailable</code></p>

		<p>Once you've got rid of old packages (using
		<strong>removepkg</strong> or the <em>remove</em>
		operation), mark the rest as foreign packages.</p>

		<p><code>slackroll unavailable-foreign</code></p>

		<p>Some people like to "blacklist" packages so they are not
		upgraded normally. Almost always, you want to do this with
		the package <em>aaa_elflibs</em> if it's present in your
		system, and maybe with some other packages. If you don't want
		them to be upgraded normally, they belong to the frozen state.
		Mark them as frozen. The same applies to customized builds
		of official packages.</p>

		<p><code>slackroll frozen aaa_elflibs</code></p>

		<p>The <em>frozen</em> operation accepts a list of packages
		as its arguments. You don't need to issue a separate command
		for each one of them.</p>

		<p>Regarding customized versions of official packages,
		there are at least three ways of dealing with them.
		Some people prefer to give them version names that match
		the official ones, despite being customized builds, and
		keep them in the installed state. The program will want
		to upgrade them automatically in that case, and maybe
		the official version will overwrite the custom one after
		an upgrade, before you rebuild it. Some other people
		prefer to do the same but putting the package in the
		frozen state. In that case, <em>list-outdated-frozen</em>
		is useful to detect version mismatches between your local
		copy and the remote ones. Finally, some other people
		prefer to give them custom version names, normally
		via personalized build numbers that usually include some
		packager initials, and mark them as frozen. In that
		case, <em>list-versions</em> can help you see if your
		local copy needs to be rebuilt for a new version.</p>

		<h2><a name="normal_operation" />Normal operation</h2>

		<p>You can run <code>slackroll help</code> to get a full list
		of operations and a brief description of each one. This program
		is not a perfect tool. I think it can handle almost every
		situation and be told to do exactly what you want, but
		reading the change log and subscribing to the
		<em>slackware-security</em> mailing list is highly
		recommended.</p>

		<p>In every case you should <em>update</em> whenever the
		remote tree is changed. Then, you should read the
		changelog with the <em>changelog</em> operation
		if there are new entries and, finally, the
		<em>list-transient</em> operation will provide a
		summary of activity. There should be no transient packages
		after you're finished.</p>

		<p>Watch out for upgrades in the <em>glibc-solibs</em>,
		<em>sed</em> and <em>pkgtools</em> packages. They
		should always be the first ones to be installed or
		upgraded in that order, even before new packages. You
		can use the <em>install</em> operation to manually
		upgrade them first, either by giving the package
		name only, which should work in most cases, or a
		specific package version. Some operations, like
		<em>install</em>, accept specific package versions
		and are copy/paste friendly. Specifying the package
		version is optional but will make sure you are
		installing the package version you really want.</p>

		<p>When installing or upgrading foreign packages,
		you can use <strong>installpkg</strong> or
		<strong>upgradepkg</strong> and then mark them as
		foreign if needed. However, you can also install
		them using the <em>install-foreign</em> operation to
		save time and avoid problems.</p>

		<p>Also, remember to run the <em>clean-cache</em> operation
		from time to time to get rid of old and outdated package
		archives stored in the package cache.</p>
		
		<h3>Rolling tree (slackware-current)</h3>

		<p>Apart from the <em>list-transient</em> operation, you
		can check for new packages with <em>list-new</em>. Decide
		to download and install them with <em>install</em> or mark
		them as not installed with <em>not-installed</em>. List
		possible upgrades with <em>list-upgrades</em> and upgrade
		to new versions with <em>upgrade</em>. Finally, list
		unavailable packages with <em>list-unavailable</em> and
		remove them or mark them as foreign if a new foreign
		package is present in the list. This may happen if you
		had forgotten to mark it when you installed it.</p>

		<h3>Stable tree</h3>

		<p>Mostly the same, but in the stable tree it's extremely
		rare to see packages being removed or being added to the
		tree, so you probably won't need to run <em>list-new</em>
		or <em>list-unavailable</em>, but you never know. The
		<em>list-transient</em> operation may be useful to detect
		these rare cases.</p>

		<h2><a name="feedback" />Feedback, questions, bug reports</h2>

		<p>I'm all open for good bug reports and general feedback
		but I'm, as always, reluctant to change the main program
		concepts, like adding support for multiple mirrors, or
		adding dependency support or probably adding more package
		states. I also know the program currently can't be used
		to upgrade the system in non-interactive mode (like
		calling it from a <em>cron</em> entry). That is very
		unlikely to change, because when there's an upgrade,
		there's no easy way to decide which version should be
		installed if a package has a version in the main tree,
		another one in <em>/extra/</em> and another one
		in <em>/testing/</em>, so it's always going to need
		user input.</p>

		<p>If you have a question, you should first read the
		<a href="faq.html">FAQ</a>. For other questions,
		comments or suggestions, my contact information can be found
		at <a href="http://freshmeat.net/~rg3/">freshmeat.net</a>.</p>

		<p>Keep in mind I'm using the program under
		<em>slackware-current</em>. If you detect a problem under
		the stable version, please report it as soon as possible
		because it may go unnoticed to me.</p>
	</body>
</html>
