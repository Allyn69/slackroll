<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
		<title>SlackRoll: Manage a Slackware system</title>
		<style type="text/css"><!--
			body {
				background: white;
				color: black;
				font-family: sans-serif;
			}
			h1 {
				text-align: center;
				background: #006699;
				color: white;
			}
			h2 {
				background: white;
				color: #006699;
				margin-left: 5%;
				margin-right: 5%;
			}
			h3 {
				margin-left: 10%;
				margin-right: 10%;
			}
			p {
				text-align: justify;
				margin-left: 15%;
				margin-right: 15%;
			}
			dl {
				text-align: justify;
				margin-left: 15%;
				margin-right: 15%;
			}
			dt {
				font-weight: bold;
				margin-top: 1ex;
				margin-bottom: 1ex;
			}
			code {
				color: red;
				background: white;
			}
			--></style>
	</head>
	<body>
		<h1>SlackRoll: Manage a Slackware system</h1>

		<h2>Target audience</h2>

		<p><strong>slackroll</strong> is a package or update manager
		for Slackware systems. It does not provide dependency
		checking and uses <strong>pkgtools</strong> to install or
		upgrade packages. It's designed to work with official
		mirrors. If you have a Slackware system mainly
		composed of official packages and a handful of
		unofficial packages, <strong>slackroll</strong>
		can help you manage it and keep in touch with the remote
		tree. It tries to know when new packages appear, when
		packages are removed and when packages are upgraded.</p>

		<h2>Before you start</h2>

		<p>So you have decided to try <strong>slackroll</strong>. Let
		me introduce a few concepts so you don't get lost.</p>

		<p><strong>slackroll</strong> works with the current directory.
		It doesn't work with a fixed system directory like, let's say,
		<code>/var/slackroll</code>. You can use
		<code>/var/slackroll</code> if you want. You have to choose
		a directory and <code>cd</code> to it before running the
		program. Want to use something inside <code>/var</code>?
		Inside <code>/root</code>? Inside <code>/media</code>?
		Whatever floats your boat.</p>

		<p>In the following text I'm going to be talking about packages.
		For package, we are going to understand a named piece of
		software, without having any specific version unless I
		explicitly mention it. A package can be <em>bash</em> or
		<em>kdewebdev</em> or <em>gcc-gfortran</em>, for example.</p>

		<p>Each package is in one of several possible states. The
		program tries to keep a persistent "database" that associates
		each package with its state. When it runs, it analyzes the list
		of packages present in your system, the list of remote packages,
		and tries to keep the persistent database updated by introducing
		new entries, deleting old ones and changing the state of some
		of those entries.</p>

		<h3>States to avoid</h3>

		<dl>

		<dt>NEW</dt> <dd>A package is in this state when it's
		present in the remote tree and it wasn't present before.
		If you detect you have packages in this state you should
		decide if you want to install them or mark them as not
		installed. This state lets you see which packages are being
		added to the remote tree.</dd>

		<dt>UNAVAILABLE</dt> <dd>Sorry if this name is
		somehow confusing. A package is in this state when it's
		present in your system, but not in the remote tree. You
		should decide if you want to remove them from your system
		or mark them as foreign packages. This state lets you
		see which packages are being removed from the remote
		tree.</dd>
		</dl>

		<h3>Normal states</h3>

		<dl>
		<dt>INSTALLED</dt> <dd>A package is installed if
		it's present in your system and in the remote tree. Very
		common state, as you can suppose.</dd>

		<dt>NOT INSTALLED</dt> <dd>A package is not
		installed if it's a known package which is not present
		in your system but exists in the remote tree. It's also
		a very common state.</dd>

		<dt>FROZEN</dt> <dd>No package will enter the frozen state
		unless you mark it so. It should be used for packages
		present in your system and in the remote tree, but that
		you don't want to upgrade automatically.  This state can
		be used for packages which are not meant to be upgraded
		automatically or ever, like <em>aaa_elflibs</em> and others,
		and for customized versions of official packages. For
		example, my custom build of <em>freetype</em> is marked as
		frozen. You must pay attention to these packages, as upgrades
		to them will be silently ignored. You may find the
		<em>list-versions</em> command useful to detect version
		mismatches between your custom builds and the remote
		packages. Having a package in the frozen state does not
		prevent you from using the <em>install</em> command to
		download and install a different version. If the package
		ever disappears from the remote tree, it will be marked
		as unavailable and you will probably see it. You could
		continue to use it by marking it as foreign if you
		wish.</dd>

		<dt>FOREIGN</dt> <dd>No package will enter the foreign
		state unless you mark it so. It should be used for
		packages present in your system because you want to have
		them, but that are not present in the remote tree.
		For example, the <em>mplayer</em> package in my system is
		marked as foreign. A foreign package will be
		marked as installed if it ever appears in the remote
		tree, becoming a candidate for upgrading. Hopefully, you'll
		notice this fact. You could still use your own version
		instead of the remote (official) one by marking it as
		frozen.</dd>

		</dl>

		<h2>Get SlackRoll</h2>

		<p><a href="http://sourceforge.net/project/showfiles.php?group_id=197236">slackroll</a>
		is a self-contained Python script released to the public
		domain. Drop it somewhere like <code>/usr/local/sbin</code>
		or <code>/usr/local/bin</code>, give it execution permissions
		and you will be ready. The available tarball contains the
		program alone. Initially I uploaded the file directly,
		but the SourceForge release system didn't let me use the
		same filename again, so I opted for a simple tarball with
		the version number in its name. If you'd prefer another
		distribution method just drop me an email message.</p>

		<h2>Getting started</h2>

		<p><strong>slackroll</strong> requires <em>python</em>,
		<em>pkgtools</em>, <em>gnupg</em> and <em>less</em> to
		operate properly.</p>

		<p>It should be noted that you can start using
		<strong>slackroll</strong> whenever you want, but my advice
		is to do it when your system is under control and there
		are no upgrades pending. This will give you a chance
		of configuring the program and setting the package states
		properly without making serious mistakes.</p>

		<p>You should first choose a working directory and a
		Slackware mirror. Create the directory, change to it and
		echo the mirror name to a file named <em>mirror</em>.</p>

		<p><code>echo 'http://slackware.osuosl.org/slackware-current/'
			&gt;mirror</code></p>

		<p><strong>Do not forget the trailing slash!</strong>
		Great. You are ready to start. Retrieve the remote GPG
		key from the mirror to add it to your keyring. Having the
		GPG key is required, and it's safe to do this step even
		if the key is already in your keyring, supposing you trust
		the mirror you chose. If you don't, get the GPG key by
		other means and add it to your keyring, skipping this
		step.</p>

		<p><code>slackroll import-key</code></p>

		<p>Retrieve information about the remote packages. You'll have
		to perform this step every time Patrick Volkerding changes the
		remote tree.</p>

		<p><code>slackroll update</code></p>

		<p>Finally, you could start checking if there are new packages,
		unavailable packages or upgrades. However, the first time you
		use <strong>slackroll</strong>, any package not installed in
		your system will be marked as new, every foreign package will
		be marked as unavailable, and every customized package will
		probably be a candidate for upgrading if you try to do so.
		If you have your system under control (and I hope you do!),
		you can in most cases blindly mark all new packages as not
		installed. There's a command to do it, being a common first
		operation.</p>

		<p><code>slackroll new-not-installed</code></p>

		<p>In most cases, you can also mark any unavailable packages as
		foreign. However, the number of foreign packages is usually
		quite low, and forgetting to uninstall a package which has been
		removed is a very common mistake, so my advice is to review
		the list of unavailable packages by hand, detecting which
		ones may not be foreign packages and need to be uninstalled.</p>

		<p><code>slackroll list-unavailable</code></p>

		<p>Once you've got rid of old packages (using
		<strong>removepkg</strong>, of course!), mark the rest as
		foreign packages.</p>

		<p><code>slackroll unavailable-foreign</code></p>

		<p>Some people like to "blacklist" packages so they are not
		upgraded normally. Almost always, you want to do this with
		the package <em>aaa_elflibs</em> if it's present in your
		system, and maybe with some other packages. If you don't want
		them to be upgraded normally, they belong to the frozen state.
		Mark them as frozen. The same applies to customized builds
		of official packages.</p>

		<p><code>slackroll frozen aaa_elflibs</code></p>

		<p>The <em>frozen</em> command accepts a list of packages
		as its arguments. You don't need to issue a separate command
		for each one of them.</p>

		<h2>Normal operation</h2>

		<p>You can run <code>slackroll help</code> to get a list of
		commands and a brief description of each one. This program
		is not a perfect tool. I think it can handle almost every
		situation and be told to do exactly what you want, but
		reading the change log and subscribing to the
		<em>slackware-security</em> mailing list is highly
		recommended.</p>

		<p>If you install a new version of <strong>slackroll</strong>,
		you should use the <em>touch</em> command (the program's
		touch command, not the system's touch command) in order to
		force the program to update the persistent database.</p>

		<p>In every case you should <em>update</em> whenever the
		remote tree is changed. Then, the <em>list-transient</em>
		command will provide a summary of activity. It should output
		an empty list once you have sorted out any changes.</p>

		<p>Watch out for upgrades in <em>glibc</em> packages.
		They should always be the first ones to be installed,
		even before new packages. The <em>install</em> command,
		among others, accepts specific package versions and is
		copy/paste friendly. You can use it to manually upgrade
		<em>glibc</em> packages first.</p>
		
		<h3>Rolling tree (slackware-current)</h3>

		<p>Check for new packages with <em>list-new</em>. Decide to
		download and install them with <em>install</em> or mark
		them as not installed with <em>not-installed</em>. List
		possible upgrades with <em>list-upgrades</em> and upgrade
		to new versions with <em>upgrade</em>. Finally, list
		unavailable packages with <em>list-unavailable</em> and
		remove them or mark them as foreign if a new foreign
		package is present in the list (which may happen if you
		had forgotten to mark it as foreign when you installed
		it).</p>

		<h3>Stable tree</h3>

		<p>Mostly the same, but in the stable tree it's extremely
		rare to see packages being removed or being added to the
		tree, so you probably won't need to run <em>list-new</em>
		or <em>list-unavailable</em>, but you never know...</p>

		<h2>Feedback, questions, bug reports</h2>

		<p>I'm all open for good bug reports and general feedback
		but I'm, as always, reluctant to change the main program
		concepts, like adding support for multiple mirrors, or
		adding dependency support or probably adding more package
		states. I also know the program currently can't be used
		to upgrade the system in non-interactive mode (like
		calling it from a <em>cron</em> entry). That is very
		unlikely to change, because when there's an upgrade,
		there's no easy way to decide which version should be
		installed if a package has a version in the main tree,
		another one in <em>/extra/</em> and another one
		in <em>/testing/</em>, so it's always going to ask.</p>

		<p>If you have any questions or suggestions, my contact
		information can be found at
		<a href="http://freshmeat.net/~rg3/">freshmeat.net</a>.</p>

		<p>Keep in mind I'm using the program under
		<em>slackware-current</em>. If you detect a problem under
		the stable version, please report it as soon as possible
		because it may go unnoticed to me.</p>
	</body>
</html>
