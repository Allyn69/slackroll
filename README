README file for SlackRoll v5

SlackRoll v5 introduces a good amount of new things that should be
clarified before you proceed to use it if you were using a previous
version. New users can simply start to use v5 directly and read
the program documentation in its webpage, which has been updated
with the new release. However, to save old users from having to re-read
the full webpage and notice the changes by themselves, I'll comment
them on this file in order of importance. Further SlackRoll releases
won't have a README file inside the tarball, as usual, unless there
are outstanding changes like in this release. I think the improvements
present in v5 make that less probable. I hope SlackRoll is more
useful with these changes and will become your swiss army knife of
package management under Slackware.



VERY IMPORTANT: PACKAGE STATE CHANGES

The previous "custom" package state is no longer present, and has been
divided into two states: "frozen" and "foreign". Like I mention
in the updated webpage, the "frozen" state is meant to be used to
block automatic package upgrades. You can use this state on packages
like aaa_elflibs and others, which should never be upgraded or should
be upgraded only when the user decides. It can also be used to block
upgrades for customized versions of official packages. For example,
the customized freetype package in my system is marked as frozen.

The "foreign" state is meant for custom packages not present in the
remote tree. This is the typical case of mplayer and any other package
you have installed because it didn't have an official version.

Summing up:

"custom" for packages with official versions is now called "frozen".
"custom" for packages without official versions is now called "foreign".

- What's the reason for having those two new states?

Having only the custom state was fine, but there are two situations
that don't cope very well with that system. Sometimes, you install
a custom package because there's not an official version. This
happened to me with ktorrent, subversion or amarok, among others.
But, as you know, Patrick Volkerding added those packages to the
official tree. With the previous system, you wouldn't notice this
change unless you read the changelog carefully. With the new system,
a foreign package is marked as installed when it appears in the
remote tree. This makes it automatically a candidate for upgrading
to the official version, which is the desirable effect in most
cases. You can still use your custom version by putting it into
the frozen state.

The second and more unusual situation was that of custom packages
which had a version in the remote tree, but that version is
removed. You wouln't notice this change unless you read the changelog
carefully. With the new system, these are frozen packages, and they
will be moved to the unavailable state if they are removed from
the remote tree. If you still want to use them despite having been
removed, mark them as foreign.

- What happens with my previous persistent database?

Don't panic. Your persistent database is still valid. To make the
transition as safe as possible, I made the old custom state code
match the frozen state code. This has an advantage: if I didn't
made a mistake and you had marked a package as custom to
"blacklist" it, like aaa_elflibs, it will still be "blacklisted"
in the frozen state. Verifying this is a good idea. The bad news
is that any custom package that should belong to the foreign
state will be moved to unavailable instead. You'll have to mark them
as foreign again with unavailable-foreign in most cases.

- How can I check frozen packages and what's this unavailable-foreign command?

As a result of the state split, some commands were removed, some
were added and some were replaced. These commands no longer exist:

	unavailable-custom
	list-custom
	custom

These commands have been introduced:

	unavailable-foreign
	list-frozen
	list-foreign
	frozen
	foreign

I think that's all I had to say about the new package states, but there
are some more changes.



IMPORTANT: IMPROVED EFFICIENCY

The program is now more efficient because it caches the list of local
packages and remote packages, and only analyzes changes and updates
the persistent database when there are changes, using the file
modification time in the same way a Make tool does. This saves
a good amount of time when you repeat commands or issue several
of them in a row, which is a usual case. However, it has a drawback:
if you installed a new version of slackroll and wanted to force
an update in the persistent database, it wasn't possible without
doing dirty things like using the update command to download the
package list again. So I introduced the "touch" command to force
an update in the persistent package database.

It is important that you run "update" or "touch" after installing
this new slackroll version.



IMPORTANT: LISTING URLS WAS BROKEN

Any commands that had to list URLs were broken due to a stupid mistake.
Nobody wrote me about this problem so maybe nobody noticed, but I
apologise in any case. I did several changes and one of them was a
very simple change to the function that printed package URLs. It was
so simple that I didn't test it, and it was broken. :(

I promise this won't happen again. I'll pay the same amount of
attention and testing to every change. The crash has been fixed.



OTHER NOTES: GLIBC WARNINGS AND OTHER COMMANDS

There is a new list-transient command that provides a summary
of activity, which many people will find useful because it's like
list-new, list-unavailable and list-upgrades combined. Under a
normal system, it should output an empty list.

The program will now detect glibc-related upgrades in both
list-upgrades and list-transient and output an outstanding
warning message so you notice, because it's very important
to always upgrade glibc first, even before installing new packages.
They can be installed with the "install" command, which accepts
specific package versions and is copy/paste friendly, in case
you hadn't noticed before. This is an example of valid usage:

$ slackroll install ./slackware/a/glibc-solibs-2.5-i486-3.tgz

It will download and install that version of glibc-solibs.
Notice that if only that version of glibc-solibs is present
in the remote tree, a mere "slackroll install glibc-solibs"
should do the right thing too. Specifying the full version
is only an option to make sure the version you want is installed.

There is a new "installed" command to unfreeze packages. Previously,
if you asked me how to mark a package as installed from custom I'd
have replied to mark it as unavailable, and let the program mark
it as installed the next time you ran it. However, due to the
new efficiency measures, this wouldn't work and I introduced the
"installed" command.

The program also caches new entries in the ChangeLog.txt file.
You'll notice that when you run update.



