#!/usr/bin/env python
# Author: Ricardo Garcia
# License: Public domain code
import anydbm
import cPickle
import glob
import os
import os.path
import re
import shelve
import socket
import subprocess
import sys
import urllib
import urlparse

slackroll_version = 6

slackroll_exit_failure = 1
slackroll_exit_success = 0

slackroll_pkg_re = re.compile(r'^(\.?/.+/)?([^/]+)-([^/-]+)-([^/-]+)-([^/-]+?)(?:\.tgz)?$')
slackroll_pkg_re_path_group = 1
slackroll_pkg_re_name_group = 2
slackroll_pkg_re_version_group = 3
slackroll_pkg_re_arch_group = 4
slackroll_pkg_re_build_group = 5

slackroll_packages_dir = './packages'
slackroll_packages_dir_glob = os.path.join(slackroll_packages_dir, '*.tgz')
slackroll_local_pkgs_glob = '/var/log/packages/*'
slackroll_local_pkgs_dir = os.path.dirname(slackroll_local_pkgs_glob)
slackroll_filelist_pkg_re = re.compile(r'^-[rwx-]{9}\s+\d+\s+\w+\s+\w+\s+\d+\s+\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}\s+(\./.+/[^/]+-[^/-]+-[^/-]+-[^/-]+\.tgz)$')
slackroll_source_indicator = '/source/'
slackroll_pasture_indicator = '/pasture/'
slackroll_patch_indicator = '/patches/'
slackroll_testing_indicator = '/testing/'
slackroll_extra_indicator = '/extra/'
slackroll_glibc_indicator = 'glibc'

slackroll_mirror_filename = 'mirror'
slackroll_persistentlist_filename = 'persistent.db'
slackroll_locallist_filename = 'local.db'
slackroll_remotelist_filename = 'remote.db'
slackroll_filelist_filename = 'FILELIST.TXT'
slackroll_changelog_filename = 'ChangeLog.txt'
slackroll_gpgkey_filename = 'GPG-KEY'
slackroll_temp_suffix = '.part'
slackroll_signature_suffix = '.asc'
slackroll_info_suffix = '.txt'

slackroll_state_new = 0
slackroll_state_unavailable = 1
slackroll_state_installed = 2
slackroll_state_notinstalled = 3
slackroll_state_frozen = 4
slackroll_state_foreign = 5
slackroll_state_outdated = 6
slackroll_state_strings = ['new', 'unavailable', 'installed', 'not-installed', 'frozen', 'foreign', 'outdated']

slackroll_mirror_version_re = re.compile(r'/slackware-([^/]+)/')
slackroll_pb_template_url = 'http://packages.slackware.it/search.php?v=%s&t=2&q=%s'
slackroll_pb_result_re = r'(?is)<div class="result">.*?<div class="pkgtitle">.*?<a[^>]*>(.+?)</a>.*?</div>.*?<div class="pkgdescr">(.+?)</div>.*?</div>'

class SlackRollError(Exception):
	pass

class SlackwarePackage:
	__name = None
	__version = None
	__arch = None
	__build = None
	__path = None

	def __init__(self, name, version, arch, build, path):
		self.__name = name
		self.__version = version
		self.__arch = arch
		self.__build = build
		if path is None:
			self.__path = ''
		else:
			self.__path = path

	def __eq__(self, other):
		return self.__name == other.__name and self.__version == other.__version and self.__arch == other.__arch and self.__build == other.__build

	def shortname(self):
		return '%s-%s-%s-%s' % (self.__name, self.__version, self.__arch, self.__build)

	def fullname(self):
		return '%s%s-%s-%s-%s.tgz' % (self.__path, self.__name, self.__version, self.__arch, self.__build)

	def name(self):
		return self.__name

	def version(self):
		return self.__version

	def arch(self):
		return self.__arch

	def build(self):
		return self.__build

	def path(self):
		return self.__path

def pkg_from_str(path_or_name): # Create a SlackwarePackage object from a string
	matchobj = slackroll_pkg_re.match(path_or_name)

	if matchobj is None:
		raise SlackRollError('No match parsing package name: %s' % path_or_name)

	path = matchobj.group(slackroll_pkg_re_path_group)
	name = matchobj.group(slackroll_pkg_re_name_group)
	version = matchobj.group(slackroll_pkg_re_version_group)
	arch = matchobj.group(slackroll_pkg_re_arch_group)
	build = matchobj.group(slackroll_pkg_re_build_group)
	return SlackwarePackage(name, version, arch, build, path)

def kibi(bytes):
	return (bytes / 1024)

def print_glibc_warning():
	print '\n!!! WATCH OUT: ACTIVITY IN GLIBC PACKAGES !!!\n'

def newer_than(path1, path2): # path1 modification time more recent than path2 modification time?
	reftime = get_mtime_or_exit(path2)
	if not os.path.exists(path1):
		return False
	modtime = get_mtime_or_exit(path1)
	return (modtime > reftime)
	
def try_dump(object, filepath):
	try:
		cPickle.dump(object, file(filepath, 'wb'), -1)
	except (OSError, IOError, cPickle.PickleError):
		sys.exit('Error: unable to dump object to file %s' % filepath)

def try_load(filepath):
	try:
		return cPickle.load(file(filepath, 'rb'))
	except (OSError, IOError, cPickle.PickleError):
		sys.exit('Error: unable to load object from file %s' % filepath)

def get_local_pkgs(): # Return a list of packages from /var/log/packages
	local_pkgs = glob.glob(slackroll_local_pkgs_glob)
	if len(local_pkgs) == 0:
		sys.exit('Error: could not read list of local packages')
	try:
		local_pkgs = [pkg_from_str(x) for x in local_pkgs]
	except SlackRollError, err:
		sys.exit('Error: %s' % err)
	return local_pkgs

def get_local_list(): # Return list of local packages from cache, updating it if needed
	if not newer_than(slackroll_locallist_filename, slackroll_local_pkgs_dir):
		print 'Rebuilding local package cache...'
		local_list = dict()
		for pkg in get_local_pkgs():
			local_list[pkg.name()] = pkg
		try_dump(local_list, slackroll_locallist_filename)
	return try_load(slackroll_locallist_filename)

def get_remote_pkgs(): # Return a list of packages from FILELIST.TXT
	try:
		lines = file(slackroll_filelist_filename, 'r').readlines()
		matches = [slackroll_filelist_pkg_re.match(x) for x in lines]
		pkgs = [x.group(1) for x in matches if x is not None]
		return [pkg_from_str(x) for x in pkgs if slackroll_source_indicator not in x]
	except IOError:
		sys.exit('Error: could not read %s' % slackroll_filelist_filename)

def get_remote_list(): # Return list of remote packages from cache, updating if needed
	if not newer_than(slackroll_remotelist_filename, slackroll_filelist_filename):
		print 'Rebuilding remote packages cache...'
		remote_list = dict()
		has_patch = dict()
		for pkg in get_remote_pkgs():
			# Mark packages with patches
			name = pkg.name()
			if slackroll_patch_indicator in pkg.path():
				has_patch[name] = True
			value = remote_list.get(name, [])
			value.append(pkg)
			remote_list[name] = value
		# Remove unpatched versions
		for name in has_patch.iterkeys():
			remote_list[name] = not_main(remote_list[name])
		try_dump(remote_list, slackroll_remotelist_filename)
	return try_load(slackroll_remotelist_filename)

def get_mirror(): # From the 'mirror' file
	try:
		lines = file(slackroll_mirror_filename, 'r').readlines()
		if len(lines) != 1:
			raise IOError()
		mirror = lines[0].strip()
		if len(mirror) == 0:
			raise IOError()
		return mirror
	except IOError:
		sys.exit('Error: %s unreadable or wrong format' % slackroll_mirror_filename)

def get_version_from_mirror(mirror): # Extract slackware version from mirror URL
	match = slackroll_mirror_version_re.search(mirror)
	if match is None:
		sys.exit('Error: unable to extract Slackware version from mirror name')
	return match.group(1)

def run_pager_on(file_path): # Does not exit on errors
	try:
		proc = subprocess.Popen(['less', file_path])
		proc.wait()
	except OSError:
		sys.stderr.write('Error: unable to run "less" on %s\n' % file_path)
		raise SlackRollError('OSError running pager on %s' % file_path)

def filelist_total_size(path_list): # Examine FILELIST.TXT and sum file sizes
	try:
		total = 0
		plist = path_list[:]
		for line in file(slackroll_filelist_filename, 'r'):
			for pos in xrange(len(plist)):
				if line.endswith('%s\n' % plist[pos]):
					total += long(line.split()[4])
					del plist[pos]
					break
		return total
	except IOError:
		sys.exit('Error: could not read %s' % slackroll_filelist_filename)

def try_to_remove(file_path):
	if not os.path.exists(file_path):
		return
	try:
		os.remove(file_path)
	except OSError:
		sys.exit('Error: unable to remove %s' % file_path)

def download_report_hook(filename, numblocks, blocksize, totalsize): # Callback for urllib.urlretrieve()
	if totalsize == -1:
		percent = 'N/A'
		kibibytes = 'N/A'
	else:
		percent = min(int(round(numblocks * blocksize * 100.0 / totalsize)), 100)
		kibibytes = kibi(totalsize)
	sys.stdout.write('\rDownloading %s ... %s%% of %sk' % (filename, percent, kibibytes))
	sys.stdout.flush()

def download_file(mirror, filepath, local_temp, local_final): # Does not exit on errors and shouldn't be called directly
	try:
		filename = os.path.basename(filepath)
		sys.stdout.write('Downloading %s ... ' % filename)
		sys.stdout.flush()
		full_url = urlparse.urljoin(mirror, filepath)
		hook = lambda a, b, c: download_report_hook(filename, a, b, c)
		urllib.urlretrieve(full_url, local_temp, hook)
		print
		os.rename(local_temp, local_final)
	except (IOError, socket.error):
		sys.stderr.write('\nError: unable to download %s\n' % full_url)
		raise SlackRollError('IOError or socket.error on %s' % full_url)
	except urllib.ContentTooShortError:
		sys.stderr.write('\nError: connection cut and file incomplete: %s\n' % full_url)
		raise SlackRollError('ContentTooShortError on %s' % full_url)
	except OSError:
		sys.stderr.write('\nError: unable to rename %s to %s\n' % (local_temp, local_final))
		raise SlackRollError('OSError renaming %s to %s' % (local_temp, local_final))

def download(mirror, filepath, localdir): # Wrapper that does NOT exit on errors
	name = os.path.basename(filepath)
	localtemp = os.path.join(localdir, '%s%s' % (name, slackroll_temp_suffix))
	localfinal = os.path.join(localdir, name)
	download_file(mirror, filepath, localtemp, localfinal)

def download_or_exit(mirror, filepath, localdir): # Wrapper that exits on errors
	try:
		download(mirror, filepath, localdir)
	except SlackRollError:
		sys.exit(slackroll_exit_failure)

def handle_writable_dir(dirname): # Make sure dirname is available and writable
	if not os.path.exists(dirname):
		try:
			os.mkdir(dirname)
		except OSError:
			sys.exit('Error: cannot create directory %s' % dirname)
	if not os.path.isdir(dirname):
		sys.exit('Error: %s exists but is not a directory' % dirname)
	if not os.access(dirname, os.R_OK | os.W_OK | os.X_OK):
		sys.exit('Error: wrong permissions for directory %s' % dirname)

def get_mtime_or_exit(path):
	try:
		return os.path.getmtime(path)
	except OSError:
		sys.exit('Error: unable to get modification time for %s' % path)

def import_key(filename):
	try:
		print 'Importing keys from %s ...' % filename
		proc = subprocess.Popen(['gpg', '--import', filename], stdout=file('/dev/null', 'w'), stderr=subprocess.STDOUT)
		retcode = proc.wait()
		if retcode != 0:
			raise OSError
	except OSError:
		sys.exit('Error: unable to import keys in %s' % filename)

def verify_signature(filename):	# Does not exit on errors
	try:
		print 'Verifying signature %s ... ' % filename
		proc = subprocess.Popen(['gpg', '--verify', filename], stdout=file('/dev/null', 'w'), stderr=subprocess.STDOUT)
		retcode = proc.wait()
		if retcode == 0:
			return
		if retcode == 1:
			sys.stderr.write('Error: signature not valid\n')
			raise SlackRollError('GnuPG exited with status code 1')
	except OSError:
		sys.stderr.write('Error: unable to verify signature in %s\n' % filename)
		raise SlackRollError('OSError running GnuPG to verify signature')

def upgrade_or_install(filename, reinstall):
	try:
		print 'Installing %s ...' % filename
		proc = subprocess.Popen(['/sbin/upgradepkg', '--install-new'] + (reinstall and ['--reinstall'] or []) + [filename])
		retcode = proc.wait()
		if retcode != 0:
			sys.exit('Error: installation failed: %s' % filename)
	except OSError:
		sys.exit('Error: unable to install %s' % filename)

def package_in_cache(package): # Check if package is in ./packages
	filepath = os.path.join(slackroll_packages_dir, os.path.basename(package.fullname()))
	return os.path.isfile(filepath) and os.access(filepath, os.R_OK)

def download_verify(mirror, package): # Download package, signature and verify it
	remote_name = package.fullname()
	remote_sig = '%s%s' % (remote_name, slackroll_signature_suffix)
	local_name = os.path.join(slackroll_packages_dir, os.path.basename(package.fullname()))
	local_sig = '%s%s' % (local_name, slackroll_signature_suffix)

	if not package_in_cache(package):
		try:
			download(mirror, remote_name, slackroll_packages_dir)
			download(mirror, remote_sig, slackroll_packages_dir)
			verify_signature(local_sig)
		except KeyboardInterrupt: # Watch out! We can't be sure the package is safe
			try_to_remove(local_name)
			try_to_remove(local_sig)
			raise KeyboardInterrupt
		except SlackRollError:
			try_to_remove(local_name)
			try_to_remove(local_sig)
			return None
		try_to_remove(local_sig)
	
	return local_name

def download_verify_install(mirror, package, reinstall=False):
	local_name = download_verify(mirror, package)
	if local_name is None:
		sys.exit(slackroll_exit_failure)
	upgrade_or_install(local_name, reinstall)

def download_display_info(mirror, package): # Downloads info file and sends it to the pager
	suffix_len = len(slackroll_info_suffix)
	remote_file = package.fullname()[:-suffix_len] + slackroll_info_suffix
	local_file = os.path.basename(remote_file)
	download_or_exit(mirror, remote_file, '.')
	try:
		run_pager_on(local_file)
	except SlackRollError:
		try_to_remove(local_file)
		sys.exit(slackroll_exit_failure)
	try_to_remove(local_file)

def update_changelog(mirror):
	if not os.path.exists(slackroll_changelog_filename):
		download_or_exit(mirror, slackroll_changelog_filename, '.')
		return

	sys.stdout.write('Updating %s ... ' % slackroll_changelog_filename)
	sys.stdout.flush()

	try: # Only read until last known entry
		limit = file(slackroll_changelog_filename, 'r').readline()
	except (OSError, IOError):
		sys.exit('Error: unable to read first line of %s' % slackroll_changelog_filename)

	try:
		changelog_url = urlparse.urljoin(mirror, slackroll_changelog_filename)
		lines = []
		conn = urllib.urlopen(changelog_url)
		while True:
			new_line = conn.readline()
			if len(new_line) == 0 or new_line == limit:
				break
			lines.append(new_line)
		conn.close()
		if len(lines) == 0:
			print 'no new entries.'
			return
		print 'new entries found.'
	except (IOError, socket.error, urllib.ContentTooShortError):
		sys.exit('Error: could not retrieve this URL: %s' % changelog_url)

	try:
		file(slackroll_changelog_filename, 'w').writelines(lines)
	except (OSError, IOError):
		sys.exit('Error: unable to write to %s' % slackroll_changelog_filename)


def print_urls(mirror, package):
	url = urlparse.urljoin(mirror, package.fullname())
	print url
	print '%s%s' % (url, slackroll_signature_suffix)

def choose_pkg(pkg_list): # Prompt user and return the package index or -1
	print 'Choose package:'
	print '    [0] None'
	for x in xrange(len(pkg_list)):
		print '    [%s] %s' % (x+1, pkg_list[x].fullname())
	while True:
		try:
			num = long(raw_input('You choose number... '))
			if num < 0 or num > len(pkg_list):
				raise ValueError
			break
		except EOFError:
			print
			continue
		except ValueError:
			continue
	return (num - 1)

def not_pasture(pkg_list): # Returns packages not in pasture
	return [x for x in pkg_list if slackroll_pasture_indicator not in x.path()]

def not_main(pkg_list): # Returns packages not in the main tree
	new_list = []
	for pkg in pkg_list:
		path = pkg.path()
		if (slackroll_patch_indicator in path or slackroll_extra_indicator in path or
		    slackroll_testing_indicator in path or slackroll_pasture_indicator in path):
			new_list.append(pkg)
	return new_list

def print_in_states(states, persistent_list, header): # Print package name if its state matches
	print header
	for name in persistent_list.iterkeys():
		if persistent_list[name] in states:
			print '    %s' % name
	print 'End of list.'
	sys.exit()

def print_keys(dictionary, header): # Print every package name in list
	print header
	for key in dictionary.iterkeys():
		print '    %s' % key
	print 'End of list.'
	sys.exit()

def from_states_to_state(orig_states, dest_state, persistent_list, pkg_names): # Changes state if it matches
	dest_st_name = slackroll_state_strings[dest_state]
	print 'Marking packages as %s...' % dest_st_name
	for name in pkg_names:
		if name not in persistent_list:
			print '%s: unknown package' % name
			continue
		cur_st = persistent_list[name]
		if cur_st not in orig_states:
			cur_st_name = slackroll_state_strings[cur_st]
			print '%s: cannot change state from %s to %s' % (name, cur_st_name, dest_st_name)
			continue
		persistent_list[name] = dest_state
		persistent_list.sync()
	sys.exit()

def query_package_browser(version, name): # Query package browser on given file with given slackware version
	searchstr = '"%s"' % name
	print 'Searching for %s:' % searchstr
	url = slackroll_pb_template_url % (urllib.quote(version), urllib.quote(searchstr))
	try:
		data = urllib.urlopen(url).read()
	except (IOError, socket.error, urllib.ContentTooShortError):
		sys.exit('Error: unable to search using this URL: %s' % url)

	# Extract results from answer webpage
	data = re.sub(r'(?s)<!--.*?-->', '', data) # Strip HTML comments
	has_results = False
	
	for match in re.finditer(slackroll_pb_result_re, data):
		has_results = True
		pkgstr = match.group(1)
		pkgcontents = match.group(2)

		print '    %s' % re.sub(r'\s', '', pkgstr)
		print ''.join(['\t%s\n' % x for x in re.split(r'(?i)<br[^>]*>', re.sub(r'(?i)(\s)|(</?b>)', '', pkgcontents))])
	
	if not has_results:
		print '    (No results)\n'

def touch_persistent_list(persistent_list): # Force an update in the modification time
	persistent_list[''] = True
	persistent_list.sync()
	del persistent_list['']
	persistent_list.sync()

def analyze_changes(local_list, remote_list, persistent_list): # XXX THIS FUNCTION IS A CENTRAL PIECE OF CODE
	already_analyzed = dict()

	# Go over packages present in local system and update their state or introduce them
	for name in local_list.iterkeys():
		already_analyzed[name] = True
		if name in persistent_list:
			# Update their state if needed
			state = persistent_list[name]
			if state in [slackroll_state_new, slackroll_state_notinstalled]:
				if name in remote_list:
					if local_list[name] in not_pasture(remote_list[name]):
						persistent_list[name] = slackroll_state_installed
					else:
						persistent_list[name] = slackroll_state_outdated
				else:
					persistent_list[name] = slackroll_state_unavailable
			elif state in [slackroll_state_unavailable, slackroll_state_foreign]:
				if name in remote_list:
					if local_list[name] in not_pasture(remote_list[name]):
						persistent_list[name] = slackroll_state_installed
					else:
						persistent_list[name] = slackroll_state_outdated
			elif state in [slackroll_state_installed, slackroll_state_outdated, slackroll_state_frozen]:
				if name not in remote_list:
					persistent_list[name] = slackroll_state_unavailable
				
		else:
			# Introduce them in the persistent list
			if name in remote_list:
				if local_list[name] in not_pasture(remote_list[name]):
					persistent_list[name] = slackroll_state_installed
				else:
					persistent_list[name] = slackroll_state_outdated
			else:
				persistent_list[name] = slackroll_state_unavailable
		persistent_list.sync()
	
	# Go over remaining remote packages not already analyzed (hence, not present in local system)
	for name in remote_list.iterkeys():
		if name in already_analyzed:
			continue
		already_analyzed[name] = True
		if name in persistent_list:
			# Update their state if needed
			state = persistent_list[name]
			if state in [slackroll_state_unavailable]:
				persistent_list[name] = slackroll_state_new
			elif state in [slackroll_state_installed, slackroll_state_outdated, slackroll_state_foreign, slackroll_state_frozen]:
				persistent_list[name] = slackroll_state_notinstalled
		else:
			# Introduce them as new
			persistent_list[name] = slackroll_state_new
		persistent_list.sync()
	
	# Remaining packages, not present in local or remote systems, need to disappear
	for name in persistent_list.keys():	# Must not use iterkeys()!
		if name in already_analyzed:
			continue
		del persistent_list[name]
		persistent_list.sync()

def print_help():
	print """Available commands:

  help			Print this help
  version		Print the program version
  update		Download remote tree information
  import-key		Download and import the GPG key
  upgrade		Upgrade system packages
  download-upgrades	Like 'upgrade' but without installing
  show-upgrade-urls	Like 'upgrade' but only printing URLs
  clean-cache		Remove unknown packages from cache
  touch			Force update on persistent database
  list-transient	Combined list of new, unavailable and outdated packages
  list-upgrades		List available upgrades
  list-alternatives	List packages with alternative versions
  list-new		List new packages
  list-unavailable	List unavailable packages
  list-installed	List installed packages
  list-not-installed	List not installed packages
  list-frozen		List frozen packages
  list-foreign		List foreign packages
  list-outdated		List outdated packages
  list-local		List all local packages (present in system)
  list-remote		List all remote packages (present in remote tree)
  list-all		List every known package
  new-not-installed	Mark all new packages as not installed
  unavailable-foreign	Mark all unavailable packages as foreign
  frozen PKG...		Mark packages as frozen
  foreign PKG...	Mark packages as foreign
  not-installed PKG...	Mark packages as not installed
  unavailable PKG...	Mark packages as unavailable
  new PKG...		Mark packages as new
  installed PKG...	Mark packages as installed
  list-versions PKG...	List all known versions of given packages
  install PKG...	Install packages or specific package versions
  reinstall PKG...	Same as 'install' but reinstalls if needed
  download PKG...	Download packages or specific package versions
  info PKG...		Show info about packages or specific package versions
  urls PKG...		Show package or specific package version URLs
  pb-search FILE...	Search for files in the Slackware Package Browser
  name-search REGEX...	Search for package names matching regular expressions

Visit http://slackroll.sourceforge.net/ for a tutorial and more help.
"""

### Main program ###
try:
	local_list = None
	remote_list = None
	persistent_list = None

	all_ops = [
		'help',
		'version',
		'update',
		'import-key',
		'upgrade',
		'download-upgrades',
		'show-upgrade-urls',
		'clean-cache',
		'touch',
		'list-transient',
		'list-upgrades',
		'list-alternatives',
		'list-new',
		'list-unavailable',
		'list-installed',
		'list-not-installed',
		'list-frozen',
		'list-foreign',
		'list-outdated',
		'list-local',
		'list-remote',
		'list-all',
		'new-not-installed',
		'unavailable-foreign',
		'frozen',
		'foreign',
		'not-installed',
		'unavailable',
		'new',
		'installed',
		'list-versions',
		'install',
		'reinstall',
		'download',
		'info',
		'urls',
		'pb-search',
		'name-search',
	]

	no_args_ops = [
		'help',
		'version',
		'update',
		'import-key',
		'upgrade',
		'download-upgrades',
		'show-upgrade-urls',
		'clean-cache',
		'touch',
		'list-transient',
		'list-upgrades',
		'list-alternatives',
		'list-new',
		'list-unavailable',
		'list-installed',
		'list-not-installed',
		'list-frozen',
		'list-foreign',
		'list-outdated',
		'list-local',
		'list-remote',
		'list-all',
		'new-not-installed',
		'unavailable-foreign',
	]

	operation = sys.argv[1]
	
	if operation not in all_ops:
		sys.stderr.write('Error: unknown command: %s\n' % operation)
		print_help()
		sys.exit(slackroll_exit_failure)

	if operation in no_args_ops and len(sys.argv[2:]) != 0:
		sys.exit('Error: too many arguments for command %s' % operation)

	if operation not in no_args_ops and len(sys.argv[2:]) == 0:
		sys.exit('Error: not enough arguments for command %s' % operation)

	if operation == 'help':
		print_help()
		sys.exit()
	
	if operation == 'version':
		print 'SlackRoll v%s' % slackroll_version
		sys.exit()

	if operation == 'update':
		mirror = get_mirror()
		download_or_exit(mirror, slackroll_filelist_filename, '.')
		update_changelog(mirror)
		sys.exit()

	if operation == 'import-key':
		download_or_exit(get_mirror(), slackroll_gpgkey_filename, '.')
		import_key(slackroll_gpgkey_filename)
		try_to_remove(slackroll_gpgkey_filename)
		sys.exit()

	if operation == 'pb-search':
		slackver = get_version_from_mirror(get_mirror())
		(scheme, netloc, path, parameters, query, fragment) = urlparse.urlparse(slackroll_pb_template_url)
		print 'Using the Slackware Package Browser at %s://%s' % (scheme, netloc)
		for name in sys.argv[2:]:
			query_package_browser(slackver, name)
		sys.exit()

	# Every operation below needs an updated persistent database
	handle_writable_dir(slackroll_packages_dir)
	print 'Initializing package lists...'
	local_list = get_local_list()
	remote_list = get_remote_list()

	needs_update = (not newer_than(slackroll_persistentlist_filename, slackroll_remotelist_filename) or
			not newer_than(slackroll_persistentlist_filename, slackroll_locallist_filename) or operation == 'touch')

	try:
		persistent_list = shelve.open(slackroll_persistentlist_filename, 'c')
	except anydbm.error:
		sys.exit('Error: unable to properly open %s' % slackroll_persistentlist_filename)

	if needs_update:
		print 'Updating persistent database...'
		analyze_changes(local_list, remote_list, persistent_list)
		touch_persistent_list(persistent_list)
	
	if operation == 'touch':
		sys.exit()

	if operation == 'upgrade' or operation == 'download-upgrades' or operation == 'show-upgrade-urls':
		mirror = get_mirror()
		chosen_pkgs = []
		for name in local_list:
			if persistent_list[name] == slackroll_state_installed:
				candidates = not_pasture(remote_list[name])
				if len(candidates) == 0:
					print 'Warning: %s only present in /pasture/' % name
					continue
				if local_list[name] not in candidates:
					if len(candidates) == 1:
						chosen_pkgs.append(candidates[0])
					else:
						print 'Local version: %s' % local_list[name].shortname()
						chosen = choose_pkg(candidates)
						if chosen >= 0:
							chosen_pkgs.append(candidates[chosen])
		
		print 'Total size: %sk' % kibi(filelist_total_size([x.fullname() for x in chosen_pkgs]))
		if operation == 'upgrade':
			action = lambda x: download_verify_install(mirror, x)
		elif operation == 'download-upgrades':
			action = lambda x: download_verify(mirror, x) is None and sys.exit(slackroll_exit_failure)
		else:
			action = lambda x: print_urls(mirror, x)
		for pkg in chosen_pkgs:
			action(pkg)
		sys.exit()

	if operation == 'clean-cache':
		cache_files = glob.glob(slackroll_packages_dir_glob)
		cache_pkgs = []
		for elem in cache_files:
			try:
				cache_pkgs.append(pkg_from_str(elem))
			except SlackRollError:
				continue
		for pkg in cache_pkgs:
			name = pkg.name()
			if (name in local_list and local_list[name] == pkg) or (name in remote_list and pkg in remote_list[name]):
				continue
			print 'Removing %s ...' % pkg.fullname()
			try_to_remove(pkg.fullname())
		sys.exit()
	
	if operation == 'list-transient':
		print 'Transient packages:'
		glibc_affected = False
		for name in persistent_list.iterkeys():
			state = persistent_list[name]
			if state in [slackroll_state_new, slackroll_state_unavailable, slackroll_state_outdated]:
				if slackroll_glibc_indicator in name:
					glibc_affected = True
				print '    %s (%s)' % (name, slackroll_state_strings[state])
		print 'End of list.'
		if glibc_affected:
			print_glibc_warning()
		sys.exit()

	if operation == 'list-upgrades':
		print 'Available upgrades:'
		glibc_affected = False
		for name in local_list:
			if persistent_list[name] == slackroll_state_installed:
				candidates = not_pasture(remote_list[name])
				if len(candidates) == 0:
					print '    %s: Warning: only present in /pasture/\n' % name
					continue
				if local_list[name] not in candidates:
					if slackroll_glibc_indicator in name:
						glibc_affected = True
					print '    %s:' % name
					print '\tLocal:\t%s' % local_list[name].shortname()
					for other in candidates:
						print '\tRemote:\t%s' % other.fullname()
					print
		print 'End of list.'
		if glibc_affected:
			print_glibc_warning()
		sys.exit()

	if operation == 'list-alternatives':
		print 'Packages with alternatives:'
		for name in persistent_list.iterkeys():
			versions = []
			if name in remote_list:
				versions.extend(remote_list[name])
			if name in local_list and local_list[name] not in versions:
				versions.append(local_list[name])
			if len(versions) > 1:
				print '    %s:' % name
				for ver in versions:
					print '\t%s %s' % (ver.path(), ver.shortname())
				print
		print 'End of list.'
		sys.exit()

	if operation == 'list-new':
		print_in_states([slackroll_state_new], persistent_list, 'New packages:')

	if operation == 'list-unavailable':
		print_in_states([slackroll_state_unavailable], persistent_list, 'Unavailable packages:')

	if operation == 'list-installed':
		print_in_states([slackroll_state_installed], persistent_list, 'Installed packages:')

	if operation == 'list-not-installed':
		print_in_states([slackroll_state_notinstalled], persistent_list, 'Not installed packages:')

	if operation == 'list-frozen':
		print_in_states([slackroll_state_frozen], persistent_list, 'Frozen packages:')

	if operation == 'list-foreign':
		print_in_states([slackroll_state_foreign], persistent_list, 'Foreign packages:')
	
	if operation == 'list-outdated':
		print_in_states([slackroll_state_outdated], persistent_list, 'Outdated packages:')
	
	if operation == 'list-local':
		print_keys(local_list, 'Local packages:')

	if operation == 'list-remote':
		print_keys(remote_list, 'Remote packages:')

	if operation == 'list-all':
		print_keys(persistent_list, 'All packages:')

	if operation == 'new-not-installed':
		from_states_to_state([slackroll_state_new], slackroll_state_notinstalled, persistent_list,
				[x for x in persistent_list.iterkeys() if persistent_list[x] == slackroll_state_new])

	if operation == 'unavailable-foreign':
		from_states_to_state([slackroll_state_unavailable], slackroll_state_foreign, persistent_list,
				[x for x in persistent_list.iterkeys() if persistent_list[x] == slackroll_state_unavailable])

	if operation == 'frozen':
		from_states_to_state([slackroll_state_frozen, slackroll_state_installed], slackroll_state_frozen, persistent_list, sys.argv[2:])

	if operation == 'foreign':
		from_states_to_state([slackroll_state_foreign, slackroll_state_unavailable], slackroll_state_foreign, persistent_list, sys.argv[2:])
	
	if operation == 'not-installed':
		from_states_to_state([slackroll_state_notinstalled, slackroll_state_new], slackroll_state_notinstalled, persistent_list, sys.argv[2:])

	if operation == 'unavailable':
		from_states_to_state([slackroll_state_unavailable, slackroll_state_foreign], slackroll_state_unavailable, persistent_list, sys.argv[2:])

	if operation == 'new':
		from_states_to_state([slackroll_state_new, slackroll_state_notinstalled], slackroll_state_new, persistent_list, sys.argv[2:])

	if operation == 'installed':
		from_states_to_state([slackroll_state_installed, slackroll_state_frozen], slackroll_state_installed, persistent_list, sys.argv[2:])

	if operation == 'list-versions':
		print 'Available versions:'
		for name in sys.argv[2:]:
			if name not in persistent_list:
				print '%s: unknown package' % name
				continue
			print '    %s:' % name
			if name in local_list:
				print '\tLocal:\t%s' % local_list[name].shortname()
			if name in remote_list:
				for ver in remote_list[name]:
					print '\tRemote:\t%s' % ver.fullname()
			print
		print 'End of list.'
		sys.exit()

	if operation == 'install' or operation == 'reinstall' or operation == 'download' or operation == 'info' or operation == 'urls':
		mirror = get_mirror()
		chosen_pkgs = []
		for arg in sys.argv[2:]:
			# Decide the type of argument
			try:
				pkg = pkg_from_str(arg)
				name = pkg.name()
				is_full = True
			except SlackRollError:
				name = arg
				is_full = False

			if name not in persistent_list:
				sys.exit('Error: unknown package %s' % name)

			if is_full:
				# Specific version given
				if name in local_list and local_list[name] == pkg and operation == 'info':
					chosen_pkgs.append(local_list[name])
				else:
					if name not in remote_list or pkg not in remote_list[name]:
						sys.exit('Error: unable to find remote package %s' % pkg.shortname())
					chosen_pkgs.append([x for x in remote_list[name] if x == pkg][0])
			else:
				# Only generic name given
				if name in local_list and operation == 'info':
					chosen_pkgs.append(local_list[name])
				else:
					if name not in remote_list:
						sys.exit('Error: unable to find remote package %s' % name)
					candidates = remote_list[name]
					if len(candidates) == 1:
						chosen_pkgs.append(candidates[0])
					else:
						if name in local_list:
							print 'Local version: %s' % local_list[name].shortname()
						chosen = choose_pkg(candidates)
						if chosen >= 0:
							chosen_pkgs.append(candidates[chosen])
	
		# After selecting the packages, run the requested operation on them
		if operation == 'install' or operation == 'reinstall' or operation == 'download' or operation == 'urls':
			print 'Total size: %sk' % kibi(filelist_total_size([x.fullname() for x in chosen_pkgs]))
			if operation == 'install':
				action = lambda x: download_verify_install(mirror, x)
			elif operation == 'reinstall':
				action = lambda x: download_verify_install(mirror, x, reinstall=True)
			elif operation == 'download':
				action = lambda x: download_verify(mirror, x) is None and sys.exit(slackroll_exit_failure)
			else:
				action = lambda x: print_urls(mirror, x)
			for pkg in chosen_pkgs:
				action(pkg)
		else:	# info operation
			for pkg in chosen_pkgs:
				name = pkg.name()
				if name in local_list and local_list[name] == pkg:
					try:
						info_file = os.path.join(pkg.path(), pkg.shortname())
						run_pager_on(info_file)
					except SlackRollError:
						sys.exit('Error: unable to run pager on %s' % info_file)
				else:
					download_display_info(mirror, pkg)
		sys.exit()

	if operation == 'name-search':
		for retxt in sys.argv[2:]:
			results = False
			try:
				regexp = re.compile(retxt)
			except re.error:
				sys.exit('Error: invalid regular expression: %s' % retxt)
			print '    %s:' % retxt
			for name in persistent_list.iterkeys():
				if regexp.search(name) is not None:
					results = True
					print '\t%s (%s)' % (name, slackroll_state_strings[persistent_list[name]])
			if not results:
				print '\t(No results)'
			print
		sys.exit()

except (KeyboardInterrupt, IOError), error:
	if isinstance(error, KeyboardInterrupt):
		print '\nProgram aborted by user'
	else:
		print '\nIOError: Broken pipe?'
	if persistent_list is not None:
		persistent_list.close()
	sys.exit(slackroll_exit_failure)

except IndexError:
	print_help()
	sys.exit(slackroll_exit_failure)
