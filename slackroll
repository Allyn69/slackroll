#!/usr/bin/env python
# Author: Ricardo Garcia
# License: Public domain code
import anydbm
import cPickle
import glob
import operator
import os
import re
import shelve
import socket
import subprocess
import sys
import urllib
import urlparse

slackroll_version = 15

slackroll_exit_failure = 1
slackroll_exit_success = 0

slackroll_pkg_re = re.compile(r'^(.*/)?([^/]+)-([^/-]+)-([^/-]+)-([^/-]+?)(\.tgz)?$')
slackroll_pkg_re_path = 1
slackroll_pkg_re_name = 2
slackroll_pkg_re_version = 3
slackroll_pkg_re_arch = 4
slackroll_pkg_re_build = 5
slackroll_pkg_re_suffix = 6

slackroll_default_temp_dir = './tmp'
slackroll_pkgs_dir_all_glob = './packages/*'
slackroll_pkgs_dir_glob = '%s.tgz' % slackroll_pkgs_dir_all_glob
slackroll_pkgs_dir = os.path.dirname(slackroll_pkgs_dir_glob)
slackroll_local_pkgs_glob = '/var/log/packages/*'
slackroll_local_pkgs_dir = os.path.dirname(slackroll_local_pkgs_glob)
slackroll_local_pkg_filelist_marker = 'FILE LIST:\n'
slackroll_filelist_pkg_re = re.compile(r'^-[rwx-]{9}\s+\d+\s+\w+\s+\w+\s+(\d+)\s+\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}\s+(\./.+/[^/]+-[^/-]+-[^/-]+-[^/-]+\.tgz)$')
slackroll_filelist_pkg_size = 1
slackroll_filelist_pkg_str = 2
slackroll_source_indicator = '/source/'
slackroll_pasture_indicator = '/pasture/'
slackroll_patch_indicator = '/patches/'
slackroll_main_indicator = '/slackware/'
slackroll_glibc_indicator = 'glibc'
slackroll_prioritized_pkgs = ['glibc-solibs', 'glibc-zoneinfo', 'glibc', 'glibc-profile', 'glibc-i18n']

slackroll_self_filename = 'self'
slackroll_mirror_filename = 'mirror'
slackroll_persistentlist_filename = 'persistent.db'
slackroll_locallist_filename = 'local.db'
slackroll_remotelist_filename = 'remote.db'
slackroll_pkg_files_filename = 'pkgfiles.db'
slackroll_known_files = 'knownfiles.db'
slackroll_filelist_filename = 'FILELIST.TXT'
slackroll_changelog_filename = 'ChangeLog.txt'
slackroll_gpgkey_filename = 'GPG-KEY'
slackroll_temp_suffix = '.part'
slackroll_signature_suffix = '.asc'
slackroll_info_suffix = '.txt'
slackroll_new_suffix = '.new'
slackroll_default_pager = 'less'
slackroll_gnupg_exec_names = ['gpg2', 'gpg']

slackroll_state_new = 0
slackroll_state_unavailable = 1
slackroll_state_installed = 2
slackroll_state_notinstalled = 3
slackroll_state_frozen = 4
slackroll_state_foreign = 5
slackroll_state_outdated = 6
slackroll_state_strings = ['new', 'unavailable', 'installed', 'not-installed', 'frozen', 'foreign', 'outdated']
slackroll_transient_states = [slackroll_state_outdated, slackroll_state_new, slackroll_state_unavailable]
slackroll_all_states = [x for x in xrange(len(slackroll_state_strings))]

slackroll_mirror_version_re = re.compile(r'/slackware-([^/]+)/')
slackroll_pb_location = 'http://packages.slackware.it/'
slackroll_pb_template_url = 'http://packages.slackware.it/search.php?v=%s&t=2&q=%s'
slackroll_pb_result_re = r'(?is)<div class="result">.*?<div class="pkgtitle">.*?<a[^>]*>(.+?)</a>.*?</div>.*?<div class="pkgdescr">(.+?)</div>.*?</div>'
slackroll_pb_result_idname = 1
slackroll_pb_result_files = 2

class SlackRollError(Exception):
	pass

class SlackwarePackage(object):
	__name = None
	__version = None
	__arch = None
	__build = None
	__path = None
	__suffix = None
	__size = None

	def __init__(self, name, version, arch, build, path, suffix, size):
		self.__name = name
		self.__version = version
		self.__arch = arch
		self.__build = build
		self.__path = (path is not None and path or '')
		self.__suffix = (suffix is not None and suffix or '')
		self.__size = size

	def __eq__(self, other):
		return self.__name == other.__name and self.__version == other.__version and self.__arch == other.__arch and self.__build == other.__build

	@property
	def name(self):
		return self.__name

	@property
	def version(self):
		return self.__version

	@property
	def arch(self):
		return self.__arch

	@property
	def build(self):
		return self.__build

	@property
	def path(self):
		return self.__path

	@property
	def suffix(self):
		return self.__suffix

	@property
	def size(self):
		return self.__size

	@property
	def idname(self):
		return '%s-%s-%s-%s' % (self.__name, self.__version, self.__arch, self.__build)

	@property
	def archivename(self):
		return '%s.tgz' % self.idname

	@property
	def fullname(self):
		return os.path.join(self.path, '%s-%s-%s-%s%s' % (self.__name, self.__version, self.__arch, self.__build, self.__suffix))

	def __cmp__(self, other):
		return pkg_name_cmp(self.__name, other.__name)

	def local(self): # Returns the equivalent local pkg
		return SlackwarePackage(self.__name, self.__version, self.__arch, self.__build, slackroll_local_pkgs_dir, None, None)

	def url(self, mirror):
		return urlparse.urljoin(mirror, self.fullname)

class SlackRollURLopener(urllib.FancyURLopener):
	def http_error_default(self, url, fp, errcode, errmsg, headers):
		raise IOError('%s: %s' % (errcode, errmsg))

def pkg_from_str(path_or_name): # Create a SlackwarePackage object from a string
	return pkg_from_name_and_size(path_or_name, None)

def pkg_from_name_and_size(path_or_name, size_str): # Create a SlackwarePackage object from a name string and a size string
	matchobj = slackroll_pkg_re.match(path_or_name)

	if matchobj is None:
		raise SlackRollError('Nonstandard package name: %s' % path_or_name)

	path = matchobj.group(slackroll_pkg_re_path)
	name = matchobj.group(slackroll_pkg_re_name)
	version = matchobj.group(slackroll_pkg_re_version)
	arch = matchobj.group(slackroll_pkg_re_arch)
	build = matchobj.group(slackroll_pkg_re_build)
	suffix = matchobj.group(slackroll_pkg_re_suffix)
	try:
		size = (size_str is not None and long(size_str) or None)
	except ValueError:
		raise SlackRollError('Invalid file size: %s' % size_str)
	return SlackwarePackage(name, version, arch, build, path, suffix, size)

def index_of(thelist, elem):
	try:
		return thelist.index(elem)
	except ValueError:
		return -1

def pkg_name_cmp(name1, name2): # To be used for sorting functions
	idx1 = index_of(slackroll_prioritized_pkgs, name1)
	idx2 = index_of(slackroll_prioritized_pkgs, name2)

	if idx1 == -1:
		if idx2 == -1:
			return cmp(name1, name2)
		return 1
	if idx2 == -1:
		return -1
	return (idx1 - idx2)

def print_flush(message):
	sys.stdout.write(message)
	sys.stdout.flush()

def get_env_or(varname, defval):
	value = os.getenv(varname)
	if value is None:
		return defval
	return value

def get_temp_dir(): # Temporary directory name
	return get_env_or('TMPDIR', slackroll_default_temp_dir)

def get_pager():
	return get_env_or('PAGER', slackroll_default_pager)

def kibi(bytes):
	return (bytes / 1024)

def get_self_file_version(): # Get self version from disk file
	try:
		data = file(slackroll_self_filename, 'r').read()
		return long(data)
	except (OSError, IOError, ValueError):
		sys.exit('ERROR: unable to read version from file %s' % slackroll_self_filename)

def write_self_file_version(): # Write self version to disk file
	try:
		file(slackroll_self_filename, 'w').write('%s\n' % slackroll_version)
	except (OSError, IOError):
		sys.exit('ERROR: unable to write version to file %s' % slackroll_self_filename)

def long_time_warning():
	print 'WARNING: This operation may take a long time to complete'

def interpret_results_warning():
	print 'WARNING: Results should be interpreted carefully'

def get_mtime_or_exit(path):
	try:
		return os.path.getmtime(path)
	except OSError:
		sys.exit('ERROR: unable to get modification time for %s' % path)

def newer_than(path1, path2): # path1 modification time more recent than path2 modification time?
	reftime = get_mtime_or_exit(path1)
	if not os.path.exists(path2):
		return True
	modtime = get_mtime_or_exit(path2)
	return (reftime > modtime)
	
def try_dump(object, filepath): # cPickle.dump()
	try:
		cPickle.dump(object, file(filepath, 'wb'), -1)
	except (OSError, IOError, cPickle.PickleError):
		sys.exit('ERROR: unable to dump object to file %s' % filepath)

def try_load(filepath): # cPickle.load()
	try:
		return cPickle.load(file(filepath, 'rb'))
	except (OSError, IOError, cPickle.PickleError):
		sys.exit('ERROR: unable to load object from file %s' % filepath)

def extract_file_list(filename): # Extracts the file list from a local info file
	try:
		lines = file(filename, 'r').readlines()
		paths = ['/%s' % x.strip().decode('string_escape') for x in lines[lines.index(slackroll_local_pkg_filelist_marker) + 1:]]
		return paths
	except ValueError:
		sys.exit('ERROR: unable to find file list marker in %s' % filename)
	except (OSError, IOError):
		sys.exit('ERROR: unable to read contents from %s' % filename)

def get_pkg_filelists(): # Return a dictionary of filename->filelist from /var/log/packages
	if newer_than(slackroll_local_pkgs_dir, slackroll_pkg_files_filename):
		try:
			filenames = glob.glob(slackroll_local_pkgs_glob)
		except (OSError, IOError):
			sys.exit('ERROR: unable to get local package list')
		contents = dict()
		for filename in filenames:
			contents[filename] = extract_file_list(filename)
		try_dump(contents, slackroll_pkg_files_filename)
	return try_load(slackroll_pkg_files_filename)

def get_normalized_known_files(): # Return a hash of known files for orphan-search
	if newer_than(slackroll_local_pkgs_dir, slackroll_known_files):
		try:
			filenames = glob.glob(slackroll_local_pkgs_glob)
		except (OSError, IOError):
			sys.exit('ERROR: unable to get local package list')
		known_files = dict()
		for pkg in filenames:
			for path in extract_file_list(pkg):
				known_files[os.path.realpath(path)] = True
		try_dump(known_files, slackroll_known_files)
	return try_load(slackroll_known_files)

def get_local_pkgs(): # Return a list of packages from /var/log/packages
	local_pkgs = glob.glob(slackroll_local_pkgs_glob)
	if len(local_pkgs) == 0:
		sys.exit('ERROR: could not read list of local packages')
	try:
		local_pkgs = [pkg_from_str(x) for x in local_pkgs]
	except SlackRollError, err:
		sys.exit('ERROR: %s' % err)
	return local_pkgs

def get_local_list(forced_rebuild): # Return list of local packages from cached list, updating it if needed
	if newer_than(slackroll_local_pkgs_dir, slackroll_locallist_filename) or forced_rebuild:
		print 'Rebuilding local package list...'
		dupes = dict()
		local_list = dict()
		for pkg in get_local_pkgs():
			name = pkg.name
			if name in local_list:
				dupes[name] = True
			value = local_list.get(name, [])
			value.append(pkg)
			local_list[name] = value
		if len(dupes) > 0:
			print 'WARNING: packages with two or more local versions should be frozen or foreign'
			print_keys(dupes, 'WARNING: list of packages with two or more local versions:', None)
		try_dump(local_list, slackroll_locallist_filename)
	return try_load(slackroll_locallist_filename)

def get_remote_pkgs(): # Return a list of packages from FILELIST.TXT
	try:
		lines = file(slackroll_filelist_filename, 'r').readlines()
		matches = [slackroll_filelist_pkg_re.match(x) for x in lines]
		nm_sz = [(x.group(slackroll_filelist_pkg_str), x.group(slackroll_filelist_pkg_size)) for x in matches if x is not None]
		return [pkg_from_name_and_size(nm, sz) for (nm, sz) in nm_sz if slackroll_source_indicator not in nm]
	except IOError:
		sys.exit('ERROR: could not read %s' % slackroll_filelist_filename)

def get_remote_list(forced_rebuild): # Return list of remote packages from cached list, updating if needed
	if newer_than(slackroll_filelist_filename, slackroll_remotelist_filename) or forced_rebuild:
		print 'Rebuilding remote packages list...'
		remote_list = dict()
		has_patch = dict()
		for pkg in get_remote_pkgs():
			# Mark packages with patches
			name = pkg.name
			if slackroll_patch_indicator in pkg.path:
				has_patch[name] = True
			value = remote_list.get(name, [])
			value.append(pkg)
			remote_list[name] = value
		# Remove unpatched versions
		for name in has_patch:
			remote_list[name] = not_main(remote_list[name])
		try_dump(remote_list, slackroll_remotelist_filename)
	return try_load(slackroll_remotelist_filename)

def get_mirror(): # From the 'mirror' file
	try:
		lines = file(slackroll_mirror_filename, 'r').readlines()
		if len(lines) != 1:
			raise IOError()
		mirror = lines[0].strip()
		if len(mirror) == 0:
			raise IOError()
		return mirror
	except IOError:
		sys.exit('ERROR: %s unreadable or wrong format' % slackroll_mirror_filename)

def get_version_from_mirror(mirror): # Extract Slackware version from mirror URL
	match = slackroll_mirror_version_re.search(mirror)
	if match is None:
		sys.exit('ERROR: unable to extract Slackware version from mirror name')
	return match.group(1)

def run_pager_on(file_path): # Does not exit on errors
	try:
		pager = get_pager()
		pager_list = pager.split()
		subprocess.call(pager_list, stdin=file(file_path, 'r'))
	except OSError:
		sys.stderr.write('ERROR: unable to run "%s" on %s\n' % (pager, file_path))
		raise SlackRollError('OSError running pager on %s' % file_path)

def run_visual_on(file_path): # Does not exit on errors
	visual = get_env_or('VISUAL', None)
	if visual is None:
		sys.stderr.write('ERROR: VISUAL environment variable not set\n')
		return
	visual_list = visual.split()
	try:
		subprocess.call(visual_list + [file_path])
	except OSError:
		sys.stderr.write('ERROR: unable to run %s on %s\n' % (visual, file_path))

def run_vimdiff_on(oldfile, newfile): # Does not exit on errors
	try:
		subprocess.call(['vimdiff', oldfile, newfile])
	except OSError:
		sys.stderr.write('ERROR: unable to run vimdiff on %s and %s\n' % (oldfile, newfile))

def try_to_remove(file_path, fatal=True): # When it returns, it is True if file does not exist on exit
	if not os.path.exists(file_path):
		return True
	try:
		os.remove(file_path)
		return True
	except OSError:
		sys.stderr.write('ERROR: unable to remove %s\n' % file_path)
		if fatal:
			sys.exit(slackroll_exit_failure)
		return False

def try_to_rename(src, dest, fatal=True): # When it returns, it is True if file could be renamed
	if not os.path.exists(src):
		return False
	try:
		os.rename(src, dest)
		return True
	except OSError:
		sys.stderr.write('ERROR: unable to rename %s to %s\n' % (src, dest))
		if fatal:
			sys.exit(slackroll_exit_failure)
		return False

def download_report_hook(filename, numblocks, blocksize, totalsize): # Template for urllib.urlretrieve() callbacks
	if totalsize == -1:
		percent = 'N/A'
		kibibytes = 'N/A'
	else:
		percent = min(int(round(numblocks * blocksize * 100.0 / totalsize)), 100)
		kibibytes = kibi(totalsize)
	print_flush('\rDownloading %s ... %s%% of %sk' % (filename, percent, kibibytes))

def download_file(mirror, filepath, local_temp, local_final): # Does not exit on errors and shouldn't be called directly
	try:
		filename = os.path.basename(filepath)
		print_flush('Downloading %s ... ' % filename)
		full_url = urlparse.urljoin(mirror, filepath)
		hook = lambda a, b, c: download_report_hook(filename, a, b, c)
		urllib.urlretrieve(full_url, local_temp, hook)
		print
		if not try_to_rename(local_temp, local_final, fatal=False):
			sys.stderr.write('ERROR: unable to rename %s to %s' % (local_temp, local_final))
			raise SlackRollError('Rename error: %s => %s' % (local_temp, local_final))
	except (IOError, socket.error):
		sys.stderr.write('\nERROR: unable to download %s\n' % full_url)
		raise SlackRollError('IOError or socket.error on %s' % full_url)
	except urllib.ContentTooShortError:
		sys.stderr.write('\nERROR: connection cut and file incomplete: %s\n' % full_url)
		raise SlackRollError('ContentTooShortError on %s' % full_url)

def download(mirror, filepath, localdir): # Wrapper that does NOT exit on errors
	name = os.path.basename(filepath)
	localtemp = os.path.join(get_temp_dir(), '%s%s' % (name, slackroll_temp_suffix))
	localfinal = os.path.join(localdir, name)
	download_file(mirror, filepath, localtemp, localfinal)

def download_or_exit(mirror, filepath, localdir): # Wrapper that exits on errors
	try:
		download(mirror, filepath, localdir)
	except SlackRollError:
		sys.exit(slackroll_exit_failure)

def handle_writable_dir(dirname): # Make sure dirname is available and writable
	if not os.path.exists(dirname):
		try:
			os.mkdir(dirname)
		except OSError:
			sys.exit('ERROR: cannot create directory %s' % dirname)
	if not os.path.isdir(dirname):
		sys.exit('ERROR: %s exists but is not a directory' % dirname)
	if not os.access(dirname, os.R_OK | os.W_OK):
		sys.exit('ERROR: wrong permissions for directory %s' % dirname)

def yield_gnupg_exec_name():
	for opt in slackroll_gnupg_exec_names:
		try:
			subprocess.call([opt, '--version'], stdout=(file('/dev/null', 'w')), stderr=subprocess.STDOUT)
			while True:
				yield opt
		except OSError:
			pass
	sys.exit('ERROR: unable to run GnuPG')

def gnupg_exec_name():
	return yield_gnupg_exec_name().next()

def import_key(filename):
	try:
		print 'Importing keys from %s ...' % filename
		retcode = subprocess.call([gnupg_exec_name(), '--import', filename], stdout=file('/dev/null', 'w'), stderr=subprocess.STDOUT)
		if retcode != 0:
			raise OSError()
	except OSError:
		sys.exit('ERROR: unable to import keys in %s' % filename)

def verify_signature(filename):	# Does not exit on errors
	try:
		print 'Verifying signature %s ... ' % os.path.basename(filename)
		retcode = subprocess.call([gnupg_exec_name(), '--verify', filename], stdout=file('/dev/null', 'w'), stderr=subprocess.STDOUT)
		if retcode != 0:
			sys.stderr.write('ERROR: signature verification failed: %s\n' % filename)
			raise SlackRollError('GnuPG exited with status code %s' % retcode)
	except OSError:
		sys.stderr.write('ERROR: unable to run GnuPG\n')
		raise SlackRollError('OSError running GnuPG to verify signature')

def upgrade_or_install(filename, reinstall): # upgradepkg
	try:
		print 'Installing %s ...' % os.path.basename(filename)
		retcode = subprocess.call(['/sbin/upgradepkg', '--install-new'] + (reinstall and ['--reinstall'] or []) + [filename])
		if retcode != 0:
			sys.exit('ERROR: installation failed: %s' % filename)
	except OSError:
		sys.exit('ERROR: unable to install %s' % filename)

def remove_pkg(removepkg_arg): # removepkg
	try:
		print 'Removing %s ...' % removepkg_arg
		retcode = subprocess.call(['/sbin/removepkg', removepkg_arg])
		if retcode != 0:
			sys.exit('ERROR: removal failed: %s' % removepkg_arg)
	except OSError:
		sys.exit('ERROR: unable to remove %s' % removepkg_arg)

def remove_pkgs(pkg_list):
	dotnew_files = extract_dotnew_files(pkg_list)
	for pkg in pkg_list:
		remove_pkg(pkg.idname)
	handle_dotnew_files_removal(dotnew_files)

def package_in_cache(package): # Check if package is in ./packages
	filepath = os.path.join(slackroll_pkgs_dir, package.archivename)
	return os.path.isfile(filepath) and os.access(filepath, os.R_OK)

def download_verify(mirror, package): # Download package, signature and verify it
	tempdir = get_temp_dir()
	remote_name = package.fullname
	remote_sig = '%s%s' % (remote_name, slackroll_signature_suffix)
	local_name = os.path.join(tempdir, package.archivename)
	local_sig = '%s%s' % (local_name, slackroll_signature_suffix)
	local_final = os.path.join(slackroll_pkgs_dir, package.archivename)

	if not package_in_cache(package):
		try:
			download(mirror, remote_name, tempdir)
			download(mirror, remote_sig, tempdir)
			verify_signature(local_sig)
		except SlackRollError:
			try_to_remove(local_sig)
			try_to_remove(local_name)
			return None
		try_to_remove(local_sig)
		try_to_rename(local_name, local_final)
	else:
		print 'Package %s found in cache' % package.idname
	
	return local_final

def download_verify_install(mirror, package, reinstall=False):
	local_name = download_verify(mirror, package)
	if local_name is None:
		sys.exit(slackroll_exit_failure)
	upgrade_or_install(local_name, reinstall)

def download_display_info(mirror, package): # Downloads info file and sends it to the pager
	suffix_len = len(slackroll_info_suffix)
	remote_file = package.fullname[:-suffix_len] + slackroll_info_suffix
	local_file = os.path.basename(remote_file)
	download_or_exit(mirror, remote_file, '.')
	try:
		run_pager_on(local_file)
	except SlackRollError:
		try_to_remove(local_file)
		sys.exit(slackroll_exit_failure)
	try_to_remove(local_file)

def update_changelog(mirror, full=False): # Returns answer to "has it been updated?"
	if not os.path.exists(slackroll_changelog_filename) or full:
		download_or_exit(mirror, slackroll_changelog_filename, '.')
		return True

	print_flush('Updating %s ... ' % slackroll_changelog_filename)

	try: # Only read until last known entry
		limit = file(slackroll_changelog_filename, 'r').readline()
	except (OSError, IOError):
		sys.exit('ERROR: unable to read first line of %s' % slackroll_changelog_filename)

	changelog_url = urlparse.urljoin(mirror, slackroll_changelog_filename)
	lines = []
	try:
		conn = urllib.urlopen(changelog_url)
		while True:
			new_line = conn.readline()
			if len(new_line) == 0 or new_line == limit:
				break
			lines.append(new_line)
		conn.close()
	except (IOError, socket.error, urllib.ContentTooShortError):
		sys.exit('ERROR: could not retrieve this URL: %s' % changelog_url)

	if len(lines) == 0:
		print 'no new entries.'
		return False
	print 'new entries found.'
	try:
		file(slackroll_changelog_filename, 'w').writelines(lines)
	except (OSError, IOError):
		sys.exit('ERROR: unable to write to %s' % slackroll_changelog_filename)
	return True

def changelog_to_pager():
	try:
		run_pager_on(slackroll_changelog_filename)
	except SlackRollError:
		sys.exit(slackroll_exit_failure)

def print_urls(mirror, package):
	url = package.url(mirror)
	print url
	print '%s%s' % (url, slackroll_signature_suffix)

def choose_option(option_list): # Prompt user and return option index
	print 'Choose option:'
	for (code, text) in option_list:
		print '    (%s) %s' % (code, text)
	codes = [x[0].lower() for x in option_list]
	while True:
		print_flush('You choose option... ')
		chosen = raw_input().lower()
		if chosen not in codes:
			continue
		break
	return codes.index(chosen)

def choose_pkg(pkg_list): # Returns chosen package or None
	options = [(str(x + 1), pkg_list[x].fullname) for x in xrange(len(pkg_list))]
	chosen = choose_option(options)
	return pkg_list[chosen]

def not_pasture(pkg_list): # Returns packages not in pasture
	return [x for x in pkg_list if slackroll_pasture_indicator not in x.path]

def not_main(pkg_list): # Returns packages not in the main tree
	return [x for x in pkg_list if slackroll_main_indicator not in x.path]

def pkgs_in_state(persistent_list, state_list): # Get persistent_list names with matching state
	return [x for x in persistent_list if persistent_list[x] in state_list]

def glibc_indicator_in(string_list): # Is the glibc indicator present in any of the strings?
	for item in string_list:
		if slackroll_glibc_indicator in item:
			return True
	return False

def glibc_activity_pending(persistent_list): # True if any new, outdated or unavailable package has glibc indicator
	return glibc_indicator_in(pkgs_in_state(persistent_list, slackroll_transient_states))

def maybe_print_glibc_watchout(persistent_list):
	if glibc_activity_pending(persistent_list):
		print '\nWATCH OUT: ACTIVITY IN GLIBC PACKAGES\n'
		return True
	return False

def maybe_print_glibc_warning(persistent_list):
	if glibc_activity_pending(persistent_list):
		print 'WARNING: It seems there is activity in glibc packages'
		return True
	return False

def maybe_print_new_warning(persistent_list):
	if len(pkgs_in_state(persistent_list, [slackroll_state_new])) > 0:
		print 'WARNING: There are new packages'
		return True
	return False

def maybe_print_outdated_warning(persistent_list):
	if len(pkgs_in_state(persistent_list, [slackroll_state_outdated])) > 0:
		print 'WARNING: There are outdated packages'
		return True
	return False

def confirm_continue():
	raw_input('Press Ctrl+C to cancel or Enter to continue... ')

def print_in_states(states, persistent_list, header, noresults, print_state=False): # Print package name if its state matches
	keys = pkgs_in_state(persistent_list, states)
	if len(keys) == 0:
		if noresults is not None:
			print noresults
		return
	print header
	keys.sort(cmp=pkg_name_cmp)
	for name in keys:
		if print_state:
			print '    %s (%s)' % (name, slackroll_state_strings[persistent_list[name]])
		else:
			print '    %s' % name
	print 'End of list'

def print_keys(dictionary, header, noresults): # Print every dictionary key, sorted with pkg_name_cmp()
	keys = dictionary.keys()
	if len(keys) == 0:
		if noresults is not None:
			print noresults
		return
	print header
	keys.sort(cmp=pkg_name_cmp)
	for key in keys:
		print '    %s' % key
	print 'End of list'

def print_list(the_list, header, noresults): # Print every list entry, sorted
	if len(the_list) == 0:
		if noresults is not None:
			print noresults
		return
	print header
	the_list.sort()
	for entry in the_list:
		print '    %s' % entry
	print 'End of list'

def from_states_to_state(orig_states, dest_state, persistent_list, pkg_names): # Changes state if it matches
	dest_st_name = slackroll_state_strings[dest_state]
	print 'Marking packages as %s...' % dest_st_name
	known = [x for x in pkg_names if x in persistent_list]
	for name in known:
		cur_st = persistent_list[name]
		if cur_st not in orig_states:
			print '%s: cannot change state from %s to %s' % (name, slackroll_state_strings[cur_st], dest_st_name)
			continue
		persistent_list[name] = dest_state
		persistent_list.sync()
	unknown = [x for x in pkg_names if x not in known]
	print_list(unknown, 'Unknown packages:', None)

def query_pkg_browser(version, name): # Query package browser on given file with given Slackware version
	searchstr = '"%s"' % name
	print 'Searching for %s:' % searchstr
	url = slackroll_pb_template_url % (urllib.quote(version), urllib.quote(searchstr))
	try:
		data = urllib.urlopen(url).read()
	except (IOError, socket.error, urllib.ContentTooShortError):
		sys.exit('ERROR: unable to search using this URL: %s' % url)

	# Extract results from answer webpage
	data = re.sub(r'(?s)<!--.*?-->', '', data) # Strip HTML comments
	has_results = False
	
	for match in re.finditer(slackroll_pb_result_re, data):
		has_results = True
		pkgstr = match.group(slackroll_pb_result_idname)
		pkgcontents = match.group(slackroll_pb_result_files)

		print '    %s' % re.sub(r'\s', '', pkgstr)
		print ''.join('\t%s\n' % x for x in re.split(r'(?i)<br[^>]*>', re.sub(r'(?i)(\s)|(</?b>)', '', pkgcontents)))
	
	if not has_results:
		print '    (No results)\n'

def extract_dotnew_files(local_pkg_list): # Get .new files from multiple packages
	return reduce(operator.concat, [[x for x in extract_file_list(pkg.fullname) if x.endswith(slackroll_new_suffix)] for pkg in local_pkg_list], [])

def old_file(dotnew_file): # Returns filename without .new suffix
	return dotnew_file[:-(len(slackroll_new_suffix))]

def handle_dotnew_files_installation(dotnew_files): # Handles .new files present in packages
	if len(dotnew_files) == 0:
		return

	existence_text = ['MISSING', 'FOUND  ']

	# Iterate over every pair of .new files
	dotnew_files.sort()
	for newfile in dotnew_files:
		oldfile = old_file(newfile)
		basenew = os.path.basename(newfile)
		baseold = os.path.basename(oldfile)

		# Every possible menu option
		go_next = ('X', 'Review next pair')
		remove_new = ('R', 'rm %s' % basenew)
		rename_new = ('M', 'mv %s %s' % (basenew, baseold))
		run_vimdiff = ('V', 'vimdiff %s %s' % (baseold, basenew))
		visual_new = ('V', '$VISUAL %s' % basenew)
		visual_old = ('V', '$VISUAL %s' % baseold)

		# Repeating options menu (break when user chooses to review next file)
		pair_iterations = 0
		while True:
			pair_iterations += 1
			try:
				new_exists = os.path.exists(newfile)
				old_exists = os.path.exists(oldfile)
			except (OSError, IOError):
				sys.stderr.write('ERROR: unable to review state of %s\n' % newfile)
				break

			print '\n%s %s' % (['Reviewing', 'Still reviewing'][pair_iterations > 1], newfile)
			print '    %s  %s' % (existence_text[old_exists], baseold)
			print '    %s  %s' % (existence_text[new_exists], basenew)

			# Different options depending on which files exist
			if new_exists and old_exists: # Both
				options = [go_next, remove_new, rename_new, run_vimdiff]
				chosen = choose_option(options)
				if chosen == 0:
					break
				elif chosen == 1:
					print 'Removing %s ...' % newfile
					try_to_remove(newfile, fatal=False)
				elif chosen == 2:
					print 'Renaming %s ...' % newfile
					try_to_rename(newfile, oldfile, fatal=False)
				else:
					run_vimdiff_on(oldfile, newfile)

			elif new_exists and not old_exists: # New only
				options = [go_next, rename_new, visual_new]
				chosen = choose_option(options)
				if chosen == 0:
					break
				if chosen == 1:
					print 'Renaming %s ...' % newfile
					try_to_rename(newfile, oldfile, fatal=False)
				else:
					run_visual_on(newfile)

			elif not new_exists and old_exists: # Old only
				options = [go_next, visual_old]
				chosen = choose_option(options)
				if chosen == 0:
					break
				else:
					run_visual_on(oldfile)
			else: # None
				options = [go_next]
				chosen = choose_option(options)
				break

def handle_dotnew_files_removal(dotnew_files):
	if len(dotnew_files) == 0:
		return

	old_files = [old_file(x) for x in dotnew_files]
	all_files = dotnew_files + old_files
	all_files.sort()

	for path in all_files:
		if not (os.path.exists(path) or os.path.islink(path)):
			continue # Does not exist in any form
		print '\nFound %s' % path
		options = [ ('K', 'Keep it'), ('R', 'Remove it') ]
		chosen = choose_option(options)
		if chosen == 1:
			try_to_remove(path, fatal=False)

def parse_pkg_arg(arg): # Returns (Is full name?, Name, SlackwarePackage or None) [Auxiliar of parse_install_args()]
	try:
		pkg = pkg_from_str(arg)
		name = pkg.name
		return (True, name, pkg)
	except SlackRollError:
		return (False, arg, None)

def parse_install_args(args, is_info, pasture, local_list, remote_list, persistent_list): # Return chosen_pkgs [Auxiliar of install_operations_family()]
	chosen_pkgs = []
	for arg in args:
		# Decide the type of argument (full name or simple name)
		(is_full, name, pkg) = parse_pkg_arg(arg)

		if name not in persistent_list:
			sys.exit('ERROR: unknown package %s' % name)

		if is_full:
			# Specific version given
			if is_info and name in local_list and pkg in local_list[name]:
				chosen_pkgs.append([x for x in local_list[name] if x == pkg][0])
			else:
				try:
					chosen_pkgs.append(remote_list[name][remote_list[name].index(pkg)])
				except (KeyError, ValueError):
					sys.exit('ERROR: unable to find remote package %s' % pkg.idname)
		else:
			# Only generic name given
			if not is_info and name not in remote_list:
				sys.exit('ERROR: unable to find remote package %s' % name)

			# Create candidate list
			candidates = []
			if is_info and name in local_list:
				candidates.extend(local_list[name])
			if name in remote_list:
				candidates.extend(x for x in remote_list[name] if x not in candidates)

			if not pasture: # Filter /pasture/ candidates if indicated
				candidates = not_pasture(candidates)

			# Choose among the candidates
			if len(candidates) == 0:
				print 'WARNING: %s only present in /pasture/' % name
			elif len(candidates) == 1:
				chosen_pkgs.append(candidates[0])
			else:
				if not is_info and name in local_list:
					for pkg in local_list[name]:
						print 'Local: %s' % pkg.idname
				chosen = choose_pkg(candidates)
				if chosen is not None:
					chosen_pkgs.append(chosen)

	return chosen_pkgs

def install_operations_family(operation, args, local_list, remote_list, persistent_list, pasture=True):
	is_real_install = (operation in ['install', 'reinstall'])
	is_info = (operation == 'info')

	# Warn the user on install and reinstall operations if there is glibc activity and they have not indicated glibc packages
	if is_real_install and not glibc_indicator_in(args) and maybe_print_glibc_warning(persistent_list):
		confirm_continue()

	# Get mirror and parse arguments (package names or full versions)
	mirror = get_mirror()
	chosen_pkgs = parse_install_args(args, is_info, pasture, local_list, remote_list, persistent_list)

	# For install and reinstall operations, trace legacy .new files
	if is_real_install:
		local_existing_pkgs = reduce(operator.concat, [local_list[pkg.name] for pkg in chosen_pkgs if pkg.name in local_list], [])
		legacy_dotnew = extract_dotnew_files(local_existing_pkgs)

	# After selecting the packages, run the requested operation on them
	if operation in ['install', 'reinstall', 'download', 'urls']:
		print 'Total size: %sk' % kibi(sum(x.size for x in chosen_pkgs))
		if operation == 'install':
			action = lambda x: download_verify_install(mirror, x)
		elif operation == 'reinstall':
			action = lambda x: download_verify_install(mirror, x, reinstall=True)
		elif operation == 'download':
			action = lambda x: download_verify(mirror, x) is None and sys.exit(slackroll_exit_failure)
		else:
			action = lambda x: print_urls(mirror, x)
		for pkg in chosen_pkgs:
			action(pkg)

		# Review installed .new files
		if is_real_install:
			dotnew_files = extract_dotnew_files([x.local() for x in chosen_pkgs])
			handle_dotnew_files_installation(dotnew_files)

	else:	# info operation
		for pkg in chosen_pkgs:
			name = pkg.name
			if name in local_list and pkg in local_list[name]:
				try:
					info_file = pkg.fullname
					run_pager_on(info_file)
				except SlackRollError:
					sys.exit('ERROR: unable to run pager on %s' % info_file)
			else:
				download_display_info(mirror, pkg)
	
	# Review legacy .new files left behind
	if is_real_install:
		previous = frozenset(legacy_dotnew)
		current = frozenset(dotnew_files)
		handle_dotnew_files_removal(list(previous - current))

def walk_append_if(root, condition, output): # Walk with os.walk() and append if entries make condition true
	abspath = os.path.abspath(root)
	for (dirpath, dirnames, filenames) in os.walk(abspath):
		for sub in dirnames + filenames:
			full = os.path.join(dirpath, sub)
			if condition(full):
				output.append(full)

def is_not_link(path):
	return not os.path.islink(path)

def is_broken_link(path):
	return os.path.islink(path) and not os.path.exists(path)

def up_to_date(local_versions, remote_versions): # Is the local package up to date?
	return (len([x for x in local_versions if x in remote_versions]) > 0)

def outdated_or_installed(local_versions, remote_versions): # Returns outdated or installed state depending on up_to_date()
	return [slackroll_state_outdated, slackroll_state_installed][up_to_date(local_versions, remote_versions)]

def analyze_changes(local_list, remote_list, persistent_list): # XXX THIS FUNCTION IS A CENTRAL PIECE OF CODE
	print 'Updating persistent database...'
	already_analyzed = dict()

	# Go over packages present in local system and update their state or introduce them
	for name in local_list:
		already_analyzed[name] = True
		if name in persistent_list:
			# Update their state if needed
			state = persistent_list[name]
			if state in [slackroll_state_new, slackroll_state_notinstalled]:
				if name in remote_list:
					persistent_list[name] = outdated_or_installed(local_list[name], not_pasture(remote_list[name]))
				else:
					persistent_list[name] = slackroll_state_unavailable
			elif state in [slackroll_state_unavailable, slackroll_state_foreign]:
				if name in remote_list:
					persistent_list[name] = outdated_or_installed(local_list[name], not_pasture(remote_list[name]))
			elif state in [slackroll_state_frozen]:
				if name not in remote_list:
					persistent_list[name] = slackroll_state_unavailable
			elif state in [slackroll_state_installed, slackroll_state_outdated]:
				if name not in remote_list:
					persistent_list[name] = slackroll_state_unavailable
				else:
					persistent_list[name] = outdated_or_installed(local_list[name], not_pasture(remote_list[name]))
				
		else:
			# Introduce them in the persistent list
			if name in remote_list:
				persistent_list[name] = outdated_or_installed(local_list[name], not_pasture(remote_list[name]))
			else:
				persistent_list[name] = slackroll_state_unavailable
		persistent_list.sync()
	
	# Go over remaining remote packages not already analyzed (hence, not present in local system)
	for name in remote_list:
		if name in already_analyzed:
			continue
		already_analyzed[name] = True
		if name in persistent_list:
			# Update their state if needed
			state = persistent_list[name]
			if state in [slackroll_state_unavailable]:
				persistent_list[name] = slackroll_state_new
			elif state in [slackroll_state_installed, slackroll_state_outdated, slackroll_state_foreign, slackroll_state_frozen]:
				persistent_list[name] = slackroll_state_notinstalled
		else:
			# Introduce them as new
			persistent_list[name] = slackroll_state_new
		persistent_list.sync()
	
	# Remaining packages, not present in local or remote systems, need to disappear
	for name in persistent_list.keys():	# Must get keys before, as we are going to delete entries
		if name in already_analyzed:
			continue
		del persistent_list[name]
		persistent_list.sync()

def print_help():
	print """Available operations:

help			Print this help
version			Print the program version
update			Download remote tree information
import-key		Download and import the GPG key
changelog		Displays the stored ChangeLog.txt
download-changelog	Download the full ChangeLog.txt
upgrade			Upgrade system packages
download-upgrades	Like 'upgrade' but without installing
urls-upgrades		Like 'upgrade' but only printing URLs
clean-cache		Remove unknown package versions from package cache
touch			Force update on persistent database
list-transient		Combined list of new, unavailable and outdated packages
list-upgrades		List available upgrades
list-outdated-frozen	List frozen packages that would be outdated otherwise
list-alternatives	List packages with alternative versions
list-versions PKG...	List all known versions of given packages
state PKG...		Show state of given packages
list-new		List new packages
list-unavailable	List unavailable packages
list-installed		List installed packages
list-not-installed	List not installed packages
list-frozen		List frozen packages
list-foreign		List foreign packages
list-outdated		List outdated packages
list-local		List all local packages (present in system)
list-remote		List all remote packages (present in remote tree)
list-all		List every known package
new-not-installed	Mark all new packages as not installed
unavailable-foreign	Mark all unavailable packages as foreign
new PKG...		Mark packages as new
unavailable PKG...	Mark packages as unavailable
installed PKG...	Mark packages as installed
not-installed PKG...	Mark packages as not installed
frozen PKG...		Mark packages as frozen
foreign PKG...		Mark packages as foreign
install PKG...		Install packages or specific package versions
install-new		Install all new packages
install-path REGEX...	Install all packages with matching path
reinstall PKG...	Same as 'install' but reinstalls if needed
download PKG...		Download packages or specific package versions
download-new		Download all new packages
download-path REGEX...	Download all packages with matching path
info PKG...		Show info about packages or specific package versions
info-new		Show info about all new packages
info-path REGEX...	Show info about all packages with matching path
urls PKG...		Show package or specific package version URLs
urls-new		Show URLs for all new packages
urls-path REGEX...	Show URLs for all packages with matching path
remove PKG...		Remove packages
remove-unavailable	Remove every unavailable package
remove-path REGEX...	Remove all packages with matching path
pb-search FILE...	Search for files in the Slackware Package Browser
remote-search FILE...	Alias for 'pb-search'
local-search REGEX...	Search for files in local packages
name-search REGEX...	Search for package names matching regular expressions
path-search REGEX...	Search for remote packages having matching path
orphan-search PATH...	Search for orphan files in local system
broken-symlinks PATH...	Search for broken symlinks in local system

Visit http://slackroll.sourceforge.net/ for a tutorial and more help.
"""

def verify_num_args(opname, num, arg_list): # Verify number of arguments of a given operation (-1 means any nonzero quantity)
	if num == -1:
		if len(arg_list) == 0:
			sys.exit('ERROR: %s expects more arguments' % opname)
	else:
		if len(arg_list) != num:
			sys.exit('ERROR: %s expects %s argument%s' % (opname, ['no', str(num)][num > 0], ['s', ''][num == 1]))

### Main program ###
try:
	local_list = None
	remote_list = None
	persistent_list = None
	urllib._urlopener = SlackRollURLopener()

	op_num_args = {	# Map of operations and their number of arguments (-1 means any nonzero quantity)
		'broken-symlinks':	-1,
		'changelog':		0,
		'clean-cache':		0,
		'download':		-1,
		'download-changelog':	0,
		'download-new':		0,
		'download-path':	-1,
		'download-upgrades':	0,
		'foreign':		-1,
		'frozen':		-1,
		'help':			0,
		'import-key':		0,
		'info':			-1,
		'info-new':		0,
		'info-path':		-1,
		'install':		-1,
		'install-new':		0,
		'install-path':		-1,
		'installed':		-1,
		'list-all':		0,
		'list-alternatives':	0,
		'list-foreign':		0,
		'list-frozen':		0,
		'list-installed':	0,
		'list-local':		0,
		'list-new':		0,
		'list-not-installed':	0,
		'list-outdated':	0,
		'list-outdated-frozen':	0,
		'list-remote':		0,
		'list-transient':	0,
		'list-unavailable':	0,
		'list-upgrades':	0,
		'list-versions':	-1,
		'local-search':		-1,
		'name-search':		-1,
		'new':			-1,
		'new-not-installed':	0,
		'not-installed':	-1,
		'orphan-search':	-1,
		'path-search':		-1,
		'pb-search':		-1,
		'reinstall':		-1,
		'remote-search':	-1,
		'remove':		-1,
		'remove-path':		-1,
		'remove-unavailable':	0,
		'urls-upgrades':	0,
		'state':		-1,
		'touch':		0,
		'unavailable':		-1,
		'unavailable-foreign':	0,
		'update':		0,
		'upgrade':		0,
		'urls':			-1,
		'urls-new':		0,
		'urls-path':		-1,
		'version':		0,
	}

	operation = sys.argv[1]
	args = sys.argv[2:]

	# Verify number of arguments
	try:
		verify_num_args(operation, op_num_args[operation], args)
	except KeyError:
		sys.stderr.write('ERROR: unknown operation: %s\n' % operation)
		print_help()
		sys.exit(slackroll_exit_failure)

	if operation == 'help':
		print_help()
		sys.exit()
	
	if operation == 'version':
		print 'SlackRoll v%s' % slackroll_version
		sys.exit()

	if operation == 'changelog':
		changelog_to_pager()
		sys.exit()

	if operation == 'download-changelog':
		update_changelog(get_mirror(), full=True)
		sys.exit()

	if operation in ['pb-search', 'remote-search']:
		slackver = get_version_from_mirror(get_mirror())
		print 'Using the Slackware Package Browser at %s' % slackroll_pb_location
		for name in sys.argv[2:]:
			query_pkg_browser(slackver, name)
		sys.exit()

	if operation == 'local-search':
		print 'Reading contents of %s ...' % slackroll_local_pkgs_dir
		pkg_files_map = get_pkg_filelists()
		local_pkgs_fn = pkg_files_map.keys()
		local_pkgs_fn.sort()
		for retxt in sys.argv[2:]:
			results = False
			try:
				regexp = re.compile(retxt)
			except re.error:
				sys.exit('ERROR: invalid regular expression: %s' % retxt)
			print 'Searching for "%s":' % retxt
			for pkg_fn in local_pkgs_fn:
				matching_paths = [x for x in pkg_files_map[pkg_fn] if regexp.search(x) is not None]
				if len(matching_paths) > 0:
					results = True
					print '    %s' % os.path.basename(pkg_fn)
					print ''.join('\t%s\n' % x for x in matching_paths)
			if not results:
				print '    (No results)\n'
		sys.exit()
	
	if operation == 'orphan-search':
		long_time_warning()
		interpret_results_warning()
		confirm_continue()

		print '\nReading normalized contents of %s ...' % slackroll_local_pkgs_dir
		known_files = get_normalized_known_files()

		print 'Examining specified paths...'
		tree = []
		for path in args: # Iterate over specified paths
			walk_append_if(path, is_not_link, tree)

		# Detect orphans
		print 'Finding orphan files...'
		orphans = []
		for name in tree:
			alternative = '%s%s' % (name, slackroll_new_suffix)
			if name not in known_files and alternative not in known_files:
				orphans.append(name)

		# Print results
		print_list(orphans, 'Orphan files:', 'No orphan files found')
		sys.exit()
	
	if operation == 'broken-symlinks':
		interpret_results_warning()
		confirm_continue()

		print '\nExamining specified paths...'
		broken_symlinks = []
		for path in args:
			walk_append_if(path, is_broken_link, broken_symlinks)

		print_list(broken_symlinks, 'Broken symlinks:', 'No broken symlinks found')
		sys.exit()

	# Some operations below need to have the temporary directory available to download stuff
	handle_writable_dir(get_temp_dir())

	if operation == 'update':
		mirror = get_mirror()
		updated = update_changelog(mirror)
		download_or_exit(mirror, slackroll_filelist_filename, '.')
		if updated:
			changelog_to_pager()
		sys.exit()

	if operation == 'import-key':
		download_or_exit(get_mirror(), slackroll_gpgkey_filename, '.')
		import_key(slackroll_gpgkey_filename)
		try_to_remove(slackroll_gpgkey_filename)
		sys.exit()

	# Every operation below needs an updated persistent database
	handle_writable_dir(slackroll_pkgs_dir)
	#print 'Initializing package lists...'

	needs_forced_rebuild = (not os.path.exists(slackroll_self_filename) or get_self_file_version() != slackroll_version)
	local_list = get_local_list(needs_forced_rebuild)
	remote_list = get_remote_list(needs_forced_rebuild)

	needs_update = (newer_than(slackroll_remotelist_filename, slackroll_persistentlist_filename)
			or newer_than(slackroll_locallist_filename, slackroll_persistentlist_filename)
			or operation == 'touch' or needs_forced_rebuild)

	try:
		persistent_list = shelve.open(slackroll_persistentlist_filename, 'c')
	except anydbm.error:
		sys.exit('ERROR: unable to properly open %s' % slackroll_persistentlist_filename)

	if needs_update:
		analyze_changes(local_list, remote_list, persistent_list)
		os.utime(slackroll_persistentlist_filename, None)

	write_self_file_version()

	if operation == 'touch':
		sys.exit()

	if operation == 'state':
		known = dict((x, persistent_list[x]) for x in args if x in persistent_list)
		print_in_states(slackroll_all_states, known, 'Package states:', None, print_state=True)
		unknown = [x for x in args if x not in known]
		print_list(unknown, 'Unknown packages:', None)
		sys.exit()

	if operation in ['upgrade', 'download-upgrades', 'urls-upgrades']:
		if operation == 'upgrade' and maybe_print_new_warning(persistent_list):
			confirm_continue()

		mirror = get_mirror()
		names = pkgs_in_state(persistent_list, [slackroll_state_outdated])
		names.sort(cmp=pkg_name_cmp)

		if len(names) == 0:
			print 'No outdated packages'
			sys.exit()

		opmap = { 'upgrade': 'install', 'download-upgrades': 'download', 'urls-upgrades': 'urls' }
		install_operations_family(opmap[operation], names, local_list, remote_list, persistent_list, pasture=False)
		sys.exit()

	if operation == 'clean-cache':
		cache_files = glob.glob(slackroll_pkgs_dir_glob)
		extraneous_files = [x for x in glob.glob(slackroll_pkgs_dir_all_glob) if x not in cache_files]

		cache_files.sort()
		cache_pkgs = []
		for elem in cache_files:
			try:
				cache_pkgs.append(pkg_from_str(elem))
			except SlackRollError:
				extraneous_files.append(elem) # Incorrect .tgz files are also extraneous

		no_files = True
		for pkg in cache_pkgs:
			name = pkg.name
			if (name in local_list and pkg in local_list[name]) or (name in remote_list and pkg in remote_list[name]):
				continue
			print 'Removing %s ...' % pkg.fullname
			try_to_remove(pkg.fullname)
			no_files = False

		extraneous_files.sort()
		for elem in extraneous_files:
			print 'WARNING: extraneous file %s' % elem

		if no_files:
			print 'No package files to remove'

		sys.exit()
	
	if operation in ['list-upgrades', 'list-outdated-frozen']:
		if operation == 'list-upgrades':
			names = pkgs_in_state(persistent_list, [slackroll_state_outdated])
		else: # list-outdated-frozen
			names = pkgs_in_state(persistent_list, [slackroll_state_frozen])
			names = [x for x in names if not up_to_date(local_list[x], not_pasture(remote_list[x]))]

		if len(names) == 0:
			if operation == 'list-upgrades':
				print 'No outdated packages'
			else: # list-outdated-frozen
				print 'No frozen packages would be outdated'
			sys.exit()

		if operation == 'list-upgrades':
			print 'Available upgrades:'
		else: # list-outdated-frozen
			print 'Would be outdated:'

		names.sort(cmp=pkg_name_cmp)
		for name in names:
			candidates = not_pasture(remote_list[name])
			if len(candidates) == 0:
				print '    %s: WARNING: only present in /pasture/\n' % name
				continue
			print '    %s:' % name
			for pkg in local_list[name]:
				print '\tLocal:\t%s' % pkg.idname
			for other in candidates:
				print '\tRemote:\t%s' % other.fullname
			print
		print 'End of list'
		if operation == 'list-upgrades':
			maybe_print_glibc_watchout(persistent_list)
		sys.exit()

	if operation == 'list-transient':
		print_in_states(slackroll_transient_states, persistent_list, 'Transient packages:', 'No transient packages found', print_state=True)
		maybe_print_glibc_watchout(persistent_list)
		sys.exit()

	if operation == 'list-alternatives':
		alternatives = dict()
		for name in persistent_list:
			versions = []
			if name in remote_list:
				versions.extend(remote_list[name])
			if name in local_list:
				versions.extend(x for x in local_list[name] if x not in versions)
			if len(versions) > 1:
				alternatives[name] = versions

		if len(alternatives) == 0:
			print 'No packages with alternative versions'
			sys.exit()

		names = alternatives.keys()
		names.sort(cmp=pkg_name_cmp)
		print 'Packages with alternatives:'
		for name in names:
			print '    %s:' % name
			for ver in alternatives[name]:
				print '\t%s' % ver.fullname
			print
		print 'End of list'
		sys.exit()

	if operation == 'list-new':
		print_in_states([slackroll_state_new], persistent_list, 'New packages:', 'No new packages found')
		maybe_print_glibc_watchout(persistent_list)
		sys.exit()

	if operation == 'list-unavailable':
		print_in_states([slackroll_state_unavailable], persistent_list, 'Unavailable packages:', 'No unavailable packages found')
		maybe_print_glibc_watchout(persistent_list)
		sys.exit()

	if operation == 'list-installed':
		print_in_states([slackroll_state_installed], persistent_list, 'Installed packages:', 'No installed packages found')
		sys.exit()

	if operation == 'list-not-installed':
		print_in_states([slackroll_state_notinstalled], persistent_list, 'Not installed packages:', 'No not-installed packages found')
		sys.exit()

	if operation == 'list-frozen':
		print_in_states([slackroll_state_frozen], persistent_list, 'Frozen packages:', 'No frozen packages found')
		sys.exit()

	if operation == 'list-foreign':
		print_in_states([slackroll_state_foreign], persistent_list, 'Foreign packages:', 'No foreign packages found')
		sys.exit()
	
	if operation == 'list-outdated':
		print_in_states([slackroll_state_outdated], persistent_list, 'Outdated packages:', 'No outdated packages found')
		maybe_print_glibc_watchout(persistent_list)
		sys.exit()
	
	if operation == 'list-local':
		print_keys(local_list, 'Local packages:', 'No local packages found')
		sys.exit()

	if operation == 'list-remote':
		print_keys(remote_list, 'Remote packages:', 'No remote packages found')
		sys.exit()

	if operation == 'list-all':
		print_keys(persistent_list, 'All packages:', 'No packages found')
		sys.exit()

	if operation == 'new-not-installed':
		new_packages = pkgs_in_state(persistent_list, [slackroll_state_new])
		from_states_to_state([slackroll_state_new], slackroll_state_notinstalled, persistent_list, new_packages)
		sys.exit()

	if operation == 'unavailable-foreign':
		unavailable_packages = pkgs_in_state(persistent_list, [slackroll_state_unavailable])
		from_states_to_state([slackroll_state_unavailable], slackroll_state_foreign, persistent_list, unavailable_packages)
		sys.exit()

	if operation == 'frozen':
		valid_origins = [slackroll_state_frozen, slackroll_state_installed, slackroll_state_outdated]
		from_states_to_state(valid_origins, slackroll_state_frozen, persistent_list, args)
		sys.exit()

	if operation == 'foreign':
		from_states_to_state([slackroll_state_foreign, slackroll_state_unavailable], slackroll_state_foreign, persistent_list, args)
		sys.exit()
	
	if operation == 'not-installed':
		from_states_to_state([slackroll_state_notinstalled, slackroll_state_new], slackroll_state_notinstalled, persistent_list, args)
		sys.exit()

	if operation == 'unavailable':
		from_states_to_state([slackroll_state_unavailable, slackroll_state_foreign], slackroll_state_unavailable, persistent_list, args)
		sys.exit()

	if operation == 'new':
		from_states_to_state([slackroll_state_new, slackroll_state_notinstalled], slackroll_state_new, persistent_list, args)
		sys.exit()

	if operation == 'installed':
		from_states_to_state([slackroll_state_installed, slackroll_state_frozen], slackroll_state_installed, persistent_list, args)
		analyze_changes(local_list, remote_list, persistent_list) # Forced because it may need to be marked as outdated
		os.utime(slackroll_persistentlist_filename, None)
		sys.exit()

	if operation == 'list-versions':
		known = [x for x in args if x in persistent_list]
		unknown = [x for x in args if x not in known]

		if len(known) > 0:
			print 'Available versions:'
			for name in known:
				print '    %s:' % name
				if name in local_list:
					print '\n'.join('\tLocal:\t%s' % ver.idname for ver in local_list[name])
				if name in remote_list:
					print '\n'.join('\tRemote:\t%s' % ver.fullname for ver in remote_list[name])
				print
			print 'End of list'

		print_list(unknown, 'Unknown packages:', None)
		sys.exit()

	if operation in ['install', 'reinstall', 'download', 'info', 'urls']:
		install_operations_family(operation, args, local_list, remote_list, persistent_list)
		sys.exit()
	
	if operation in ['install-new', 'download-new', 'info-new', 'urls-new']:
		names = pkgs_in_state(persistent_list, [slackroll_state_new])
		names.sort(cmp=pkg_name_cmp)
		if len(names) == 0:
			print 'No new packages'
			sys.exit()
		opname = operation.replace('-new', '')
		install_operations_family(opname, names, local_list, remote_list, persistent_list)
		sys.exit()
	
	if operation in ['install-path', 'download-path', 'info-path', 'urls-path', 'remove-path']:
		regexes = []
		for retxt in args:
			try:
				regexes.append(re.compile(retxt))
			except re.error:
				sys.exit('ERROR: invalid regular expression: %s' % retxt)

		all_remotes = reduce(operator.concat, [remote_list[x] for x in remote_list], [])
		matching_pkgs = []
		for pkg in all_remotes:
			for regex in regexes:
				if regex.search(pkg.path) is not None:
					matching_pkgs.append(pkg)
					break

		if operation == 'remove-path': # Filter out packages not present in local system
			matching_pkgs = [x for x in matching_pkgs if x.name in local_list and x in local_list[x.name]]

		if len(matching_pkgs) == 0:
			print 'No matching packages'
			sys.exit()

		matching_pkgs.sort()
		if operation == 'remove-path':
			if maybe_print_new_warning(persistent_list) or maybe_print_outdated_warning(persistent_list):
				confirm_continue()
			remove_pkgs([x.local() for x in matching_pkgs])
		else:
			opname = operation.replace('-path', '')
			fullnames = [x.fullname for x in matching_pkgs]
			install_operations_family(opname, fullnames, local_list, remote_list, persistent_list)

		sys.exit()

	if operation in ['remove', 'remove-unavailable']:
		if maybe_print_new_warning(persistent_list) or maybe_print_outdated_warning(persistent_list):
			confirm_continue()

		if operation == 'remove':
			final_args = []
			for name in args:
				if name not in local_list:
					sys.exit('ERROR: %s not present in local system' % name)
				final_args.append(name)
		else: # remove-unavailable
			final_args = pkgs_in_state(persistent_list, [slackroll_state_unavailable])

		if len(final_args) == 0:
			print 'No packages to remove'
			sys.exit()

		to_be_removed = []
		if operation == 'remove':
			for name in final_args:
				candidates = local_list[name]
				if len(candidates) == 1:
					to_be_removed.append(candidates[0])
					continue
				chosen = choose_pkg(candidates)
				if chosen is not None:
					to_be_removed.append(chosen)
		else: # remove-unavailable
			for name in final_args:
				to_be_removed.extend(local_list[name])

		remove_pkgs(to_be_removed)
		sys.exit()

	if operation == 'name-search':
		for retxt in args:
			results = False
			try:
				regexp = re.compile(retxt)
			except re.error:
				sys.exit('ERROR: invalid regular expression: %s' % retxt)
			print 'Searching for "%s":' % retxt
			names = [x for x in persistent_list if regexp.search(x) is not None]
			names.sort(cmp=pkg_name_cmp)
			if len(names) == 0:
				print '    (No results)\n'
				continue
			print ''.join('    %s (%s)\n' % (x, slackroll_state_strings[persistent_list[x]]) for x in names)
		sys.exit()
	
	if operation == 'path-search':
		all_remotes = reduce(operator.concat, [remote_list[x] for x in remote_list], [])
		for retxt in args:
			try:
				regexp = re.compile(retxt)
			except re.error:
				sys.exit('ERROR: invalid regular expression: %s' % retxt)
			print 'Searching for "%s":' % retxt
			matching_fullnames = [x.fullname for x in all_remotes if regexp.search(x.path) is not None]
			matching_fullnames.sort()
			if len(matching_fullnames) == 0:
				print '    (No results)\n'
			else:
				print ''.join('    %s\n' % x for x in matching_fullnames)
		sys.exit()
	
except (KeyboardInterrupt, IOError, EOFError), error:
	if isinstance(error, KeyboardInterrupt):
		sys.stderr.write('\nProgram aborted by user\n')
	elif isinstance(error, IOError):
		sys.stderr.write('\nIOError: Broken pipe?\n')
	else:
		sys.stderr.write('\nEOF found, exiting\n')
	if persistent_list is not None:
		persistent_list.close()
	sys.exit(slackroll_exit_failure)

except IndexError:
	print_help()
	sys.exit(slackroll_exit_failure)
