#!/usr/bin/env python
# Author: Ricardo Garcia
# License: Public domain code
import anydbm
import cPickle
import glob
import os
import os.path
import re
import shelve
import socket
import subprocess
import sys
import urllib
import urlparse

slackroll_version = 12

slackroll_exit_failure = 1
slackroll_exit_success = 0

slackroll_pkg_re = re.compile(r'^(.*/)?([^/]+)-([^/-]+)-([^/-]+)-([^/-]+?)(\.tgz)?$')
slackroll_pkg_re_path_group = 1
slackroll_pkg_re_name_group = 2
slackroll_pkg_re_version_group = 3
slackroll_pkg_re_arch_group = 4
slackroll_pkg_re_build_group = 5
slackroll_pkg_re_suffix_group = 6

slackroll_default_temp_dir = './tmp'
slackroll_pkgs_dir_all_glob = './packages/*'
slackroll_pkgs_dir_glob = '%s.tgz' % slackroll_pkgs_dir_all_glob
slackroll_pkgs_dir = os.path.dirname(slackroll_pkgs_dir_glob)
slackroll_local_pkgs_glob = '/var/log/packages/*'
slackroll_local_pkgs_dir = os.path.dirname(slackroll_local_pkgs_glob)
slackroll_local_pkg_filelist_marker = 'FILE LIST:\n'
slackroll_filelist_pkg_re = re.compile(r'^-[rwx-]{9}\s+\d+\s+\w+\s+\w+\s+\d+\s+\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}\s+(\./.+/[^/]+-[^/-]+-[^/-]+-[^/-]+\.tgz)$')
slackroll_source_indicator = '/source/'
slackroll_pasture_indicator = '/pasture/'
slackroll_patch_indicator = '/patches/'
slackroll_main_indicator = '/slackware/'
slackroll_glibc_indicator = 'glibc'
slackroll_prioritized_pkgs = ['glibc-solibs', 'glibc-zoneinfo', 'glibc', 'glibc-profile', 'glibc-i18n']

slackroll_self_filename = 'self'
slackroll_mirror_filename = 'mirror'
slackroll_persistentlist_filename = 'persistent.db'
slackroll_locallist_filename = 'local.db'
slackroll_remotelist_filename = 'remote.db'
slackroll_filelist_filename = 'FILELIST.TXT'
slackroll_changelog_filename = 'ChangeLog.txt'
slackroll_gpgkey_filename = 'GPG-KEY'
slackroll_temp_suffix = '.part'
slackroll_signature_suffix = '.asc'
slackroll_info_suffix = '.txt'
slackroll_new_suffix = '.new'

slackroll_state_new = 0
slackroll_state_unavailable = 1
slackroll_state_installed = 2
slackroll_state_notinstalled = 3
slackroll_state_frozen = 4
slackroll_state_foreign = 5
slackroll_state_outdated = 6
slackroll_state_strings = ['new', 'unavailable', 'installed', 'not-installed', 'frozen', 'foreign', 'outdated']

slackroll_mirror_version_re = re.compile(r'/slackware-([^/]+)/')
slackroll_pb_template_url = 'http://packages.slackware.it/search.php?v=%s&t=2&q=%s'
slackroll_pb_result_re = r'(?is)<div class="result">.*?<div class="pkgtitle">.*?<a[^>]*>(.+?)</a>.*?</div>.*?<div class="pkgdescr">(.+?)</div>.*?</div>'

class SlackRollError(Exception):
	pass

class SlackwarePackage(object):
	__name = None
	__version = None
	__arch = None
	__build = None
	__path = None
	__suffix = None

	def __init__(self, name, version, arch, build, path, suffix):
		self.__name = name
		self.__version = version
		self.__arch = arch
		self.__build = build
		self.__path = (path is not None and path or '')
		self.__suffix = (suffix is not None and suffix or '')

	def __eq__(self, other):
		return self.__name == other.__name and self.__version == other.__version and self.__arch == other.__arch and self.__build == other.__build

	@property
	def name(self):
		return self.__name

	@property
	def version(self):
		return self.__version

	@property
	def arch(self):
		return self.__arch

	@property
	def build(self):
		return self.__build

	@property
	def path(self):
		return self.__path

	@property
	def suffix(self):
		return self.__suffix

	@property
	def idname(self):
		return '%s-%s-%s-%s' % (self.name, self.version, self.arch, self.build)

	@property
	def archivename(self):
		return '%s.tgz' % self.idname

	@property
	def fullname(self):
		return os.path.join(self.path, '%s-%s-%s-%s%s' % (self.name, self.version, self.arch, self.build, self.suffix))

class SlackRollURLopener(urllib.FancyURLopener):
	def http_error_default(self, url, fp, errcode, errmsg, headers):
		raise IOError('%s: %s' % (errcode, errmsg))

def pkg_from_str(path_or_name): # Create a SlackwarePackage object from a string
	matchobj = slackroll_pkg_re.match(path_or_name)

	if matchobj is None:
		raise SlackRollError('Nonstandard package name: %s' % path_or_name)

	path = matchobj.group(slackroll_pkg_re_path_group)
	name = matchobj.group(slackroll_pkg_re_name_group)
	version = matchobj.group(slackroll_pkg_re_version_group)
	arch = matchobj.group(slackroll_pkg_re_arch_group)
	build = matchobj.group(slackroll_pkg_re_build_group)
	suffix = matchobj.group(slackroll_pkg_re_suffix_group)
	return SlackwarePackage(name, version, arch, build, path, suffix)

def index_of(thelist, elem):
	try:
		return thelist.index(elem)
	except ValueError:
		return -1

def pkg_cmp(name1, name2):
	idx1 = index_of(slackroll_prioritized_pkgs, name1)
	idx2 = index_of(slackroll_prioritized_pkgs, name2)

	if idx1 == -1:
		if idx2 == -1:
			return cmp(name1, name2)
		return 1
	if idx2 == -1:
		return -1
	return (idx1 - idx2)

def get_temp_dir():
	tempdir = os.getenv('TMPDIR')
	return (tempdir is None and slackroll_default_temp_dir or tempdir)

def kibi(bytes):
	return (bytes / 1024)

def get_self_file_version():
	try:
		data = file(slackroll_self_filename, 'r').read()
		return long(data)
	except (OSError, IOError, ValueError):
		sys.exit('Error: unable to read version from file %s' % slackroll_self_filename)

def write_self_file_version():
	try:
		file(slackroll_self_filename, 'w').write('%s\n' % slackroll_version)
	except (OSError, IOError):
		sys.exit('Error: unable to write version to file %s' % slackroll_self_filename)

def print_glibc_warning():
	print '\n!!! WATCH OUT: ACTIVITY IN GLIBC PACKAGES !!!\n'

def newer_than(path1, path2): # path1 modification time more recent than path2 modification time?
	reftime = get_mtime_or_exit(path2)
	if not os.path.exists(path1):
		return False
	modtime = get_mtime_or_exit(path1)
	return (modtime > reftime)
	
def try_dump(object, filepath):
	try:
		cPickle.dump(object, file(filepath, 'wb'), -1)
	except (OSError, IOError, cPickle.PickleError):
		sys.exit('Error: unable to dump object to file %s' % filepath)

def try_load(filepath):
	try:
		return cPickle.load(file(filepath, 'rb'))
	except (OSError, IOError, cPickle.PickleError):
		sys.exit('Error: unable to load object from file %s' % filepath)

def get_local_pkgs(): # Return a list of packages from /var/log/packages
	local_pkgs = glob.glob(slackroll_local_pkgs_glob)
	if len(local_pkgs) == 0:
		sys.exit('Error: could not read list of local packages')
	try:
		local_pkgs = [pkg_from_str(x) for x in local_pkgs]
	except SlackRollError, err:
		sys.exit('Error: %s' % err)
	return local_pkgs

def get_local_list(forced_rebuild): # Return list of local packages from cached list, updating it if needed
	if not newer_than(slackroll_locallist_filename, slackroll_local_pkgs_dir) or forced_rebuild:
		print 'Rebuilding local package list...'
		local_list = dict()
		for pkg in get_local_pkgs():
			local_list[pkg.name] = pkg
		try_dump(local_list, slackroll_locallist_filename)
	return try_load(slackroll_locallist_filename)

def get_remote_pkgs(): # Return a list of packages from FILELIST.TXT
	try:
		lines = file(slackroll_filelist_filename, 'r').readlines()
		matches = [slackroll_filelist_pkg_re.match(x) for x in lines]
		pkgs = [x.group(1) for x in matches if x is not None]
		return [pkg_from_str(x) for x in pkgs if slackroll_source_indicator not in x]
	except IOError:
		sys.exit('Error: could not read %s' % slackroll_filelist_filename)

def get_remote_list(forced_rebuild): # Return list of remote packages from cached list, updating if needed
	if not newer_than(slackroll_remotelist_filename, slackroll_filelist_filename) or forced_rebuild:
		print 'Rebuilding remote packages list...'
		remote_list = dict()
		has_patch = dict()
		for pkg in get_remote_pkgs():
			# Mark packages with patches
			name = pkg.name
			if slackroll_patch_indicator in pkg.path:
				has_patch[name] = True
			value = remote_list.get(name, [])
			value.append(pkg)
			remote_list[name] = value
		# Remove unpatched versions
		for name in has_patch.iterkeys():
			remote_list[name] = not_main(remote_list[name])
		try_dump(remote_list, slackroll_remotelist_filename)
	return try_load(slackroll_remotelist_filename)

def get_mirror(): # From the 'mirror' file
	try:
		lines = file(slackroll_mirror_filename, 'r').readlines()
		if len(lines) != 1:
			raise IOError()
		mirror = lines[0].strip()
		if len(mirror) == 0:
			raise IOError()
		return mirror
	except IOError:
		sys.exit('Error: %s unreadable or wrong format' % slackroll_mirror_filename)

def get_version_from_mirror(mirror): # Extract slackware version from mirror URL
	match = slackroll_mirror_version_re.search(mirror)
	if match is None:
		sys.exit('Error: unable to extract Slackware version from mirror name')
	return match.group(1)

def run_pager_on(file_path): # Does not exit on errors
	try:
		subprocess.call(['less', file_path])
	except OSError:
		sys.stderr.write('Error: unable to run "less" on %s\n' % file_path)
		raise SlackRollError('OSError running pager on %s' % file_path)

def run_visual_on(file_path): # Does not exit on errors
	visual = os.getenv('VISUAL')
	if visual is None:
		sys.stderr.write('Error: VISUAL environment variable not set\n')
		return
	try:
		subprocess.call([visual, file_path])
	except OSError:
		sys.stderr.write('Error: unable to run %s on %s\n' % (visual, file_path))

def run_vimdiff_on(oldfile, newfile): # Does not exit on errors
	try:
		subprocess.call(['vimdiff', oldfile, newfile])
	except OSError:
		sys.stderr.write('Error: unable to run vimdiff on %s and %s\n' % (oldfile, newfile))

def filelist_total_size(path_list): # Examine FILELIST.TXT and sum file sizes
	try:
		total = 0
		plist = path_list[:]
		for line in file(slackroll_filelist_filename, 'r'):
			for pos in xrange(len(plist)):
				if line.endswith('%s\n' % plist[pos]):
					total += long(line.split()[4])
					del plist[pos]
					break
		if len(plist) > 0:
			sys.exit('Error: unable to get size for every package')
		return total
	except IOError:
		sys.exit('Error: could not read %s' % slackroll_filelist_filename)

def try_to_remove(file_path, fatal=True):
	if not os.path.exists(file_path):
		return
	try:
		os.remove(file_path)
	except OSError:
		sys.stderr.write('Error: unable to remove %s\n' % file_path)
		if fatal:
			sys.exit(slackroll_exit_failure)

def try_to_rename(src, dest, fatal=True):
	if not os.path.exists(src):
		return
	try:
		os.rename(src, dest)
	except OSError:
		sys.stderr.write('Error: unable to rename %s to %s\n' % (src, dest))
		if fatal:
			sys.exit(slackroll_exit_failure)

def download_report_hook(filename, numblocks, blocksize, totalsize): # Callback for urllib.urlretrieve()
	if totalsize == -1:
		percent = 'N/A'
		kibibytes = 'N/A'
	else:
		percent = min(int(round(numblocks * blocksize * 100.0 / totalsize)), 100)
		kibibytes = kibi(totalsize)
	sys.stdout.write('\rDownloading %s ... %s%% of %sk' % (filename, percent, kibibytes))
	sys.stdout.flush()

def download_file(mirror, filepath, local_temp, local_final): # Does not exit on errors and shouldn't be called directly
	try:
		filename = os.path.basename(filepath)
		sys.stdout.write('Downloading %s ... ' % filename)
		sys.stdout.flush()
		full_url = urlparse.urljoin(mirror, filepath)
		hook = lambda a, b, c: download_report_hook(filename, a, b, c)
		urllib.urlretrieve(full_url, local_temp, hook)
		print
		os.rename(local_temp, local_final)
	except (IOError, socket.error):
		sys.stderr.write('\nError: unable to download %s\n' % full_url)
		raise SlackRollError('IOError or socket.error on %s' % full_url)
	except urllib.ContentTooShortError:
		sys.stderr.write('\nError: connection cut and file incomplete: %s\n' % full_url)
		raise SlackRollError('ContentTooShortError on %s' % full_url)
	except OSError:
		sys.stderr.write('\nError: unable to rename %s to %s\n' % (local_temp, local_final))
		raise SlackRollError('OSError renaming %s to %s' % (local_temp, local_final))

def download(mirror, filepath, localdir): # Wrapper that does NOT exit on errors
	name = os.path.basename(filepath)
	localtemp = os.path.join(get_temp_dir(), '%s%s' % (name, slackroll_temp_suffix))
	localfinal = os.path.join(localdir, name)
	download_file(mirror, filepath, localtemp, localfinal)

def download_or_exit(mirror, filepath, localdir): # Wrapper that exits on errors
	try:
		download(mirror, filepath, localdir)
	except SlackRollError:
		sys.exit(slackroll_exit_failure)

def handle_writable_dir(dirname): # Make sure dirname is available and writable
	if not os.path.exists(dirname):
		try:
			os.mkdir(dirname)
		except OSError:
			sys.exit('Error: cannot create directory %s' % dirname)
	if not os.path.isdir(dirname):
		sys.exit('Error: %s exists but is not a directory' % dirname)
	if not os.access(dirname, os.R_OK | os.W_OK):
		sys.exit('Error: wrong permissions for directory %s' % dirname)

def get_mtime_or_exit(path):
	try:
		return os.path.getmtime(path)
	except OSError:
		sys.exit('Error: unable to get modification time for %s' % path)

def import_key(filename):
	try:
		print 'Importing keys from %s ...' % filename
		retcode = subprocess.call(['gpg', '--import', filename], stdout=file('/dev/null', 'w'), stderr=subprocess.STDOUT)
		if retcode != 0:
			raise OSError
	except OSError:
		sys.exit('Error: unable to import keys in %s' % filename)

def verify_signature(filename):	# Does not exit on errors
	try:
		print 'Verifying signature %s ... ' % os.path.basename(filename)
		retcode = subprocess.call(['gpg', '--verify', filename], stdout=file('/dev/null', 'w'), stderr=subprocess.STDOUT)
		if retcode != 0:
			sys.stderr.write('Error: bad signature\n')
			raise SlackRollError('GnuPG exited with status code %s' % retcode)
	except OSError:
		sys.stderr.write('Error: unable to verify signature in %s\n' % filename)
		raise SlackRollError('OSError running GnuPG to verify signature')

def upgrade_or_install(filename, reinstall):
	try:
		print 'Installing %s ...' % os.path.basename(filename)
		retcode = subprocess.call(['/sbin/upgradepkg', '--install-new'] + (reinstall and ['--reinstall'] or []) + [filename])
		if retcode != 0:
			sys.exit('Error: installation failed: %s' % filename)
	except OSError:
		sys.exit('Error: unable to install %s' % filename)

def remove_pkg(removepkg_arg):
	try:
		print 'Removing %s ...' % removepkg_arg
		retcode = subprocess.call(['/sbin/removepkg', removepkg_arg])
		if retcode != 0:
			sys.exit('Error: removal failed: %s' % removepkg_arg)
	except OSError:
		sys.exit('Error: unable to remove %s' % removepkg_arg)

def package_in_cache(package): # Check if package is in ./packages
	filepath = os.path.join(slackroll_pkgs_dir, package.archivename)
	return os.path.isfile(filepath) and os.access(filepath, os.R_OK)

def download_verify(mirror, package): # Download package, signature and verify it
	tempdir = get_temp_dir()
	remote_name = package.fullname
	remote_sig = '%s%s' % (remote_name, slackroll_signature_suffix)
	local_name = os.path.join(tempdir, package.archivename)
	local_sig = '%s%s' % (local_name, slackroll_signature_suffix)
	local_final = os.path.join(slackroll_pkgs_dir, package.archivename)

	if not package_in_cache(package):
		try:
			download(mirror, remote_name, tempdir)
			download(mirror, remote_sig, tempdir)
			verify_signature(local_sig)
		except SlackRollError:
			try_to_remove(local_sig)
			try_to_remove(local_name)
			return None
		try_to_remove(local_sig)
		try_to_rename(local_name, local_final)
	else:
		print 'Package %s found in cache' % package.idname
	
	return local_final

def download_verify_install(mirror, package, reinstall=False):
	local_name = download_verify(mirror, package)
	if local_name is None:
		sys.exit(slackroll_exit_failure)
	upgrade_or_install(local_name, reinstall)

def download_display_info(mirror, package): # Downloads info file and sends it to the pager
	suffix_len = len(slackroll_info_suffix)
	remote_file = package.fullname[:-suffix_len] + slackroll_info_suffix
	local_file = os.path.basename(remote_file)
	download_or_exit(mirror, remote_file, '.')
	try:
		run_pager_on(local_file)
	except SlackRollError:
		try_to_remove(local_file)
		sys.exit(slackroll_exit_failure)
	try_to_remove(local_file)

def update_changelog(mirror):
	if not os.path.exists(slackroll_changelog_filename):
		download_or_exit(mirror, slackroll_changelog_filename, '.')
		return

	sys.stdout.write('Updating %s ... ' % slackroll_changelog_filename)
	sys.stdout.flush()

	try: # Only read until last known entry
		limit = file(slackroll_changelog_filename, 'r').readline()
	except (OSError, IOError):
		sys.exit('Error: unable to read first line of %s' % slackroll_changelog_filename)

	try:
		changelog_url = urlparse.urljoin(mirror, slackroll_changelog_filename)
		lines = []
		conn = urllib.urlopen(changelog_url)
		while True:
			new_line = conn.readline()
			if len(new_line) == 0 or new_line == limit:
				break
			lines.append(new_line)
		conn.close()
		if len(lines) == 0:
			print 'no new entries.'
			return
		print 'new entries found.'
	except (IOError, socket.error, urllib.ContentTooShortError):
		sys.exit('Error: could not retrieve this URL: %s' % changelog_url)

	try:
		file(slackroll_changelog_filename, 'w').writelines(lines)
	except (OSError, IOError):
		sys.exit('Error: unable to write to %s' % slackroll_changelog_filename)


def print_urls(mirror, package):
	url = urlparse.urljoin(mirror, package.fullname)
	print url
	print '%s%s' % (url, slackroll_signature_suffix)

def choose_option(option_list): # Prompt user and return option index
	print 'Choose option:'
	for (code, text) in option_list:
		print '    (%s) %s' % (code, text)
	codes = [x[0].lower() for x in option_list]
	while True:
		try:
			sys.stdout.write('You choose option... ')
			sys.stdout.flush()
			chosen = raw_input().lower()
			if chosen not in codes:
				continue
			break
		except EOFError:
			print
			continue
	return codes.index(chosen)

def choose_pkg(pkg_list): # Returns chosen package or None
	options_pkg = [None] + pkg_list
	options = [('0', 'None')]
	for x in xrange(len(pkg_list)):
		options.append((str(x + 1), pkg_list[x].fullname))
	chosen = choose_option(options)
	return options_pkg[chosen]

def confirm_continue():
	try:
		raw_input('Press Ctrl+C to cancel or Enter to continue... ')
	except EOFError:
		pass

def not_pasture(pkg_list): # Returns packages not in pasture
	return [x for x in pkg_list if slackroll_pasture_indicator not in x.path]

def not_main(pkg_list): # Returns packages not in the main tree
	return [x for x in pkg_list if slackroll_main_indicator not in x.path]

def print_in_states(states, persistent_list, header): # Print package name if its state matches
	print header
	keys = [x for x in persistent_list if persistent_list[x] in states]
	keys.sort(cmp=pkg_cmp)
	for name in keys:
		print '    %s' % name
	print 'End of list'
	sys.exit()

def print_keys(dictionary, header): # Print every package name in list
	print header
	keys = dictionary.keys()
	keys.sort(cmp=pkg_cmp)
	for key in keys:
		print '    %s' % key
	print 'End of list'
	sys.exit()

def from_states_to_state(orig_states, dest_state, persistent_list, pkg_names, exit_flag=True): # Changes state if it matches
	dest_st_name = slackroll_state_strings[dest_state]
	print 'Marking packages as %s...' % dest_st_name
	for name in pkg_names:
		if name not in persistent_list:
			print '%s: unknown package' % name
			continue
		cur_st = persistent_list[name]
		if cur_st not in orig_states:
			cur_st_name = slackroll_state_strings[cur_st]
			print '%s: cannot change state from %s to %s' % (name, cur_st_name, dest_st_name)
			continue
		persistent_list[name] = dest_state
		persistent_list.sync()
	if exit_flag:
		sys.exit()

def query_pkg_browser(version, name): # Query package browser on given file with given slackware version
	searchstr = '"%s"' % name
	print 'Searching for %s:' % searchstr
	url = slackroll_pb_template_url % (urllib.quote(version), urllib.quote(searchstr))
	try:
		data = urllib.urlopen(url).read()
	except (IOError, socket.error, urllib.ContentTooShortError):
		sys.exit('Error: unable to search using this URL: %s' % url)

	# Extract results from answer webpage
	data = re.sub(r'(?s)<!--.*?-->', '', data) # Strip HTML comments
	has_results = False
	
	for match in re.finditer(slackroll_pb_result_re, data):
		has_results = True
		pkgstr = match.group(1)
		pkgcontents = match.group(2)

		print '    %s' % re.sub(r'\s', '', pkgstr)
		print ''.join(['\t%s\n' % x for x in re.split(r'(?i)<br[^>]*>', re.sub(r'(?i)(\s)|(</?b>)', '', pkgcontents))])
	
	if not has_results:
		print '    (No results)\n'

def extract_file_list(filename):
	try:
		lines = file(filename, 'r').readlines()
		paths = ['/%s' % x.strip() for x in lines[lines.index(slackroll_local_pkg_filelist_marker) + 1:]]
		return paths
	except ValueError:
		sys.exit('Error: unable to find file list marker in %s' % filename)
	except (OSError, IOError):
		sys.exit('Error: unable to read contents from %s' % filename)

def equiv_local_pkg(pkg): # Converts a package to the equivalent local package
	return SlackwarePackage(pkg.name, pkg.version, pkg.arch, pkg.build, slackroll_local_pkgs_dir, None)

def handle_dotnew_files(package_list): # Handles .new files present in packages
	local_files = [equiv_local_pkg(x).fullname for x in package_list]
	new_files = []
	for filename in local_files:
		new_files.extend([x for x in extract_file_list(filename) if x.endswith(slackroll_new_suffix)])
	new_files.sort()
	
	if len(new_files) == 0:
		return

	existence_text = ['MISSING', 'FOUND  ']
	for newfile in new_files:
		oldfile = newfile[:-(len(slackroll_new_suffix))]
		basenew = os.path.basename(newfile)
		baseold = os.path.basename(oldfile)

		# Option texts
		go_next = ('X', 'Review next pair')
		remove_new = ('R', 'rm %s' % basenew)
		rename_new = ('M', 'mv %s %s' % (basenew, baseold))
		run_vimdiff = ('V', 'vimdiff %s %s' % (baseold, basenew))
		visual_new = ('V', '$VISUAL %s' % basenew)
		visual_old = ('V', '$VISUAL %s' % baseold)

		# Repeating options menu (break when user chooses to review next file)
		pair_iterations = 0
		while True:
			pair_iterations += 1
			try:
				new_exists = os.path.exists(newfile)
				old_exists = os.path.exists(oldfile)
			except (OSError, IOError):
				sys.stderr.write('Error: unable to review state of %s\n' % newfile)
				break

			print '\n%s %s' % (['Reviewing', 'Still reviewing'][pair_iterations > 1], newfile)
			print '    %s  %s' % (existence_text[old_exists], baseold)
			print '    %s  %s' % (existence_text[new_exists], basenew)

			# Different options depending on which files exist
			if new_exists:
				if old_exists:
					# Both exist
					options = [go_next, remove_new, rename_new, run_vimdiff]
					chosen = choose_option(options)
					if chosen == 0:
						break
					elif chosen == 1:
						print 'Removing %s ...' % newfile
						try_to_remove(newfile, fatal=False)
					elif chosen == 2:
						print 'Renaming %s ...' % newfile
						try_to_rename(newfile, oldfile, fatal=False)
					else:
						run_vimdiff_on(oldfile, newfile)
				else:
					# Only .new file exists
					options = [go_next, rename_new, visual_new]
					chosen = choose_option(options)
					if chosen == 0:
						break
					if chosen == 1:
						print 'Renaming %s ...' % newfile
						try_to_rename(newfile, oldfile, fatal=False)
					else:
						run_visual_on(newfile)
			else:
				if old_exists:
					# Only old file exists
					options = [go_next, visual_old]
					chosen = choose_option(options)
					if chosen == 0:
						break
					else:
						run_visual_on(oldfile)
				else:
					# None exists
					options = [go_next]
					chosen = choose_option(options)
					break

	print '\nNo more files to review'

def install_operations_family(operation, args, local_list, remote_list, persistent_list):
	# Warn the user on install and reinstall operations if there is glibc
	# activity and they have not indicated glibc packages
	if (operation in ['install', 'reinstall']
	    and len([x for x in args if slackroll_glibc_indicator in x]) == 0
	    and len([x for x in persistent_list if persistent_list[x] in [slackroll_state_new, slackroll_state_outdated]
		    				   and slackroll_glibc_indicator in x]) > 0):
		print 'Warning: it seems there is activity in glibc packages'
		confirm_continue()

	mirror = get_mirror()
	chosen_pkgs = []
	for arg in args:
		# Decide the type of argument
		try:
			pkg = pkg_from_str(arg)
			name = pkg.name
			is_full = True
		except SlackRollError:
			name = arg
			is_full = False

		if name not in persistent_list:
			sys.exit('Error: unknown package %s' % name)

		if is_full:
			# Specific version given
			if name in local_list and local_list[name] == pkg and operation == 'info':
				chosen_pkgs.append(local_list[name])
			else:
				if name not in remote_list or pkg not in remote_list[name]:
					sys.exit('Error: unable to find remote package %s' % pkg.idname)
				chosen_pkgs.append([x for x in remote_list[name] if x == pkg][0])
		else:
			# Only generic name given
			if name not in remote_list and operation != 'info':
				sys.exit('Error: unable to find remote package %s' % name)

			candidates = []
			if name in local_list and operation == 'info':
				candidates.append(local_list[name])
			if name in remote_list:
				candidates.extend([x for x in remote_list[name] if x not in candidates])
			if len(candidates) == 1:
				chosen_pkgs.append(candidates[0])
			else:
				if name in local_list and operation != 'info':
					print 'Local: %s' % local_list[name].idname
				chosen = choose_pkg(candidates)
				if chosen is not None:
					chosen_pkgs.append(chosen)

	# After selecting the packages, run the requested operation on them
	if operation in ['install', 'reinstall', 'download', 'urls']:
		print 'Total size: %sk' % kibi(filelist_total_size([x.fullname for x in chosen_pkgs]))
		if operation == 'install':
			action = lambda x: download_verify_install(mirror, x)
		elif operation == 'reinstall':
			action = lambda x: download_verify_install(mirror, x, reinstall=True)
		elif operation == 'download':
			action = lambda x: download_verify(mirror, x) is None and sys.exit(slackroll_exit_failure)
		else:
			action = lambda x: print_urls(mirror, x)
		for pkg in chosen_pkgs:
			action(pkg)
		if operation in ['install', 'reinstall']:
			handle_dotnew_files(chosen_pkgs)
	else:	# info operation
		for pkg in chosen_pkgs:
			name = pkg.name
			if name in local_list and local_list[name] == pkg:
				try:
					info_file = local_list[name].fullname
					run_pager_on(info_file)
				except SlackRollError:
					sys.exit('Error: unable to run pager on %s' % info_file)
			else:
				download_display_info(mirror, pkg)
	sys.exit()

def analyze_changes(local_list, remote_list, persistent_list): # XXX THIS FUNCTION IS A CENTRAL PIECE OF CODE
	print 'Updating persistent database...'
	already_analyzed = dict()

	# Go over packages present in local system and update their state or introduce them
	for name in local_list.iterkeys():
		already_analyzed[name] = True
		if name in persistent_list:
			# Update their state if needed
			state = persistent_list[name]
			if state in [slackroll_state_new, slackroll_state_notinstalled]:
				if name in remote_list:
					up_to_date = local_list[name] in not_pasture(remote_list[name])
					persistent_list[name] = [slackroll_state_outdated, slackroll_state_installed][up_to_date]
				else:
					persistent_list[name] = slackroll_state_unavailable
			elif state in [slackroll_state_unavailable, slackroll_state_foreign]:
				if name in remote_list:
					up_to_date = local_list[name] in not_pasture(remote_list[name])
					persistent_list[name] = [slackroll_state_outdated, slackroll_state_installed][up_to_date]
			elif state in [slackroll_state_frozen]:
				if name not in remote_list:
					persistent_list[name] = slackroll_state_unavailable
			elif state in [slackroll_state_installed, slackroll_state_outdated]:
				if name not in remote_list:
					persistent_list[name] = slackroll_state_unavailable
				else:
					up_to_date = local_list[name] in not_pasture(remote_list[name])
					persistent_list[name] = [slackroll_state_outdated, slackroll_state_installed][up_to_date]
				
		else:
			# Introduce them in the persistent list
			if name in remote_list:
				up_to_date = local_list[name] in not_pasture(remote_list[name])
				persistent_list[name] = [slackroll_state_outdated, slackroll_state_installed][up_to_date]
			else:
				persistent_list[name] = slackroll_state_unavailable
		persistent_list.sync()
	
	# Go over remaining remote packages not already analyzed (hence, not present in local system)
	for name in remote_list.iterkeys():
		if name in already_analyzed:
			continue
		already_analyzed[name] = True
		if name in persistent_list:
			# Update their state if needed
			state = persistent_list[name]
			if state in [slackroll_state_unavailable]:
				persistent_list[name] = slackroll_state_new
			elif state in [slackroll_state_installed, slackroll_state_outdated, slackroll_state_foreign, slackroll_state_frozen]:
				persistent_list[name] = slackroll_state_notinstalled
		else:
			# Introduce them as new
			persistent_list[name] = slackroll_state_new
		persistent_list.sync()
	
	# Remaining packages, not present in local or remote systems, need to disappear
	for name in persistent_list.keys():	# Must not use iterkeys()!
		if name in already_analyzed:
			continue
		del persistent_list[name]
		persistent_list.sync()

def print_help():
	print """Available operations:

  help			Print this help
  version		Print the program version
  update		Download remote tree information
  import-key		Download and import the GPG key
  upgrade		Upgrade system packages
  download-upgrades	Like 'upgrade' but without installing
  show-upgrade-urls	Like 'upgrade' but only printing URLs
  clean-cache		Remove unknown package versions from package cache
  touch			Force update on persistent database
  list-transient	Combined list of new, unavailable and outdated packages
  list-upgrades		List available upgrades
  list-alternatives	List packages with alternative versions
  list-versions PKG...	List all known versions of given packages
  state PKG...		Show state of given packages
  list-new		List new packages
  list-unavailable	List unavailable packages
  list-installed	List installed packages
  list-not-installed	List not installed packages
  list-frozen		List frozen packages
  list-foreign		List foreign packages
  list-outdated		List outdated packages
  list-local		List all local packages (present in system)
  list-remote		List all remote packages (present in remote tree)
  list-all		List every known package
  new-not-installed	Mark all new packages as not installed
  unavailable-foreign	Mark all unavailable packages as foreign
  new PKG...		Mark packages as new
  unavailable PKG...	Mark packages as unavailable
  installed PKG...	Mark packages as installed
  not-installed PKG...	Mark packages as not installed
  frozen PKG...		Mark packages as frozen
  foreign PKG...	Mark packages as foreign
  install PKG...	Install packages or specific package versions
  install-new		Install all new packages
  reinstall PKG...	Same as 'install' but reinstalls if needed
  download PKG...	Download packages or specific package versions
  download-new		Download all new packages
  info PKG...		Show info about packages or specific package versions
  info-new		Show info about all new packages
  urls PKG...		Show package or specific package version URLs
  urls-new		Show URLs for all new packages
  remove PKG...		Remove packages
  remove-unavailable	Remove every unavailable package
  pb-search FILE...	Search for files in the Slackware Package Browser
  remote-search FILE...	Alias for 'pb-search'
  local-search REGEX...	Search for files in local packages
  name-search REGEX...	Search for package names matching regular expressions
  path-search REGEX...	Search for remote packages having matching path

Visit http://slackroll.sourceforge.net/ for a tutorial and more help.
"""

### Main program ###
try:
	local_list = None
	remote_list = None
	persistent_list = None
	urllib._urlopener = SlackRollURLopener()

	all_ops = [
		'clean-cache',
		'download',
		'download-new',
		'download-upgrades',
		'foreign',
		'frozen',
		'help',
		'import-key',
		'info',
		'info-new',
		'install',
		'install-new',
		'installed',
		'list-all',
		'list-alternatives',
		'list-foreign',
		'list-frozen',
		'list-installed',
		'list-local',
		'list-new',
		'list-not-installed',
		'list-outdated',
		'list-remote',
		'list-transient',
		'list-unavailable',
		'list-upgrades',
		'list-versions',
		'local-search',
		'name-search',
		'new',
		'new-not-installed',
		'not-installed',
		'path-search',
		'pb-search',
		'reinstall',
		'remote-search',
		'remove',
		'remove-unavailable',
		'show-upgrade-urls',
		'state',
		'touch',
		'unavailable',
		'unavailable-foreign',
		'update',
		'upgrade',
		'urls',
		'urls-new',
		'version',
	]

	no_args_ops = [
		'clean-cache',
		'download-new',
		'download-upgrades',
		'help',
		'import-key',
		'info-new',
		'install-new',
		'list-all',
		'list-alternatives',
		'list-foreign',
		'list-frozen',
		'list-installed',
		'list-local',
		'list-new',
		'list-not-installed',
		'list-outdated',
		'list-remote',
		'list-transient',
		'list-unavailable',
		'list-upgrades',
		'new-not-installed',
		'remove-unavailable',
		'show-upgrade-urls',
		'touch',
		'unavailable-foreign',
		'update',
		'upgrade',
		'urls-new',
		'version',
	]

	operation = sys.argv[1]
	
	if operation not in all_ops:
		sys.stderr.write('Error: unknown operation: %s\n' % operation)
		print_help()
		sys.exit(slackroll_exit_failure)

	if operation in no_args_ops and len(sys.argv[2:]) != 0:
		sys.exit('Error: too many arguments for %s operation' % operation)

	if operation not in no_args_ops and len(sys.argv[2:]) == 0:
		sys.exit('Error: not enough arguments for %s operation' % operation)

	if operation == 'help':
		print_help()
		sys.exit()
	
	if operation == 'version':
		print 'SlackRoll v%s' % slackroll_version
		sys.exit()

	if operation in ['pb-search', 'remote-search']:
		slackver = get_version_from_mirror(get_mirror())
		(scheme, netloc, path, parameters, query, fragment) = urlparse.urlparse(slackroll_pb_template_url)
		print 'Using the Slackware Package Browser at %s://%s' % (scheme, netloc)
		for name in sys.argv[2:]:
			query_pkg_browser(slackver, name)
		sys.exit()

	if operation == 'local-search':
		print 'Reading contents of %s ...' % slackroll_local_pkgs_dir
		try:
			filenames = glob.glob(slackroll_local_pkgs_glob)
		except (OSError, IOError):
			sys.exit('Error: unable to get local package list')
		filenames.sort()
		contents = dict()
		for filename in filenames:
			contents[filename] = extract_file_list(filename)
		for retxt in sys.argv[2:]:
			results = False
			try:
				regexp = re.compile(retxt)
			except re.error:
				sys.exit('Error: invalid regular expression: %s' % retxt)
			print 'Searching for "%s":' % retxt
			for filename in filenames:
				name_printed = False
				for path in contents[filename]:
					if regexp.search(path) is not None:
						if not name_printed:
							print '    %s' % os.path.basename(filename)
							name_printed = True
						print '\t%s' % path
						results = True
				if name_printed:
					print
			if not results:
				print '    (No results)\n'
		sys.exit()
	
	# Some operations below need to have the temporary directory available to download stuff
	handle_writable_dir(get_temp_dir())

	if operation == 'update':
		mirror = get_mirror()
		download_or_exit(mirror, slackroll_filelist_filename, '.')
		update_changelog(mirror)
		sys.exit()

	if operation == 'import-key':
		download_or_exit(get_mirror(), slackroll_gpgkey_filename, '.')
		import_key(slackroll_gpgkey_filename)
		try_to_remove(slackroll_gpgkey_filename)
		sys.exit()

	# Every operation below needs an updated persistent database
	handle_writable_dir(slackroll_pkgs_dir)
	print 'Initializing package lists...'

	needs_forced_rebuild = (not os.path.exists(slackroll_self_filename) or get_self_file_version() != slackroll_version)
	local_list = get_local_list(needs_forced_rebuild)
	remote_list = get_remote_list(needs_forced_rebuild)

	needs_update = (not newer_than(slackroll_persistentlist_filename, slackroll_remotelist_filename)
			or not newer_than(slackroll_persistentlist_filename, slackroll_locallist_filename)
			or operation == 'touch' or needs_forced_rebuild)

	try:
		persistent_list = shelve.open(slackroll_persistentlist_filename, 'c')
	except anydbm.error:
		sys.exit('Error: unable to properly open %s' % slackroll_persistentlist_filename)

	if needs_update:
		analyze_changes(local_list, remote_list, persistent_list)
		os.utime(slackroll_persistentlist_filename, None)

	write_self_file_version()

	if operation == 'touch':
		sys.exit()

	if operation == 'state':
		print 'Package states:'
		for name in sys.argv[2:]:
			if name not in persistent_list:
				print '    %s: unknown package' % name
				continue
			print '    %s: %s' % (name, slackroll_state_strings[persistent_list[name]])
		print 'End of list'
		sys.exit()

	if operation in ['upgrade', 'download-upgrades', 'show-upgrade-urls']:
		mirror = get_mirror()
		names = [x for x in local_list if persistent_list[x] == slackroll_state_outdated]
		names.sort(cmp=pkg_cmp)

		if len(names) == 0:
			print 'No outdated packages'
			sys.exit()

		chosen_pkgs = []
		for name in names:
			candidates = not_pasture(remote_list[name])
			if len(candidates) == 0:
				print 'Warning: %s only present in /pasture/' % name
				continue
			if len(candidates) == 1:
				chosen_pkgs.append(candidates[0])
			else:
				print 'Local: %s' % local_list[name].idname
				chosen = choose_pkg(candidates)
				if chosen is not None:
					chosen_pkgs.append(chosen)
		
		print 'Total size: %sk' % kibi(filelist_total_size([x.fullname for x in chosen_pkgs]))
		if operation == 'upgrade':
			action = lambda x: download_verify_install(mirror, x)
		elif operation == 'download-upgrades':
			action = lambda x: download_verify(mirror, x) is None and sys.exit(slackroll_exit_failure)
		else:
			action = lambda x: print_urls(mirror, x)
		for pkg in chosen_pkgs:
			action(pkg)
		if operation == 'upgrade':
			handle_dotnew_files(chosen_pkgs)
		sys.exit()

	if operation == 'clean-cache':
		cache_files = glob.glob(slackroll_pkgs_dir_glob)
		extraneous_files = [x for x in glob.glob(slackroll_pkgs_dir_all_glob) if x not in cache_files]

		cache_files.sort()
		cache_pkgs = []
		for elem in cache_files:
			try:
				cache_pkgs.append(pkg_from_str(elem))
			except SlackRollError:
				extraneous_files.append(elem) # Incorrect .tgz files are also extraneous

		no_files = True
		for pkg in cache_pkgs:
			name = pkg.name
			if (name in local_list and local_list[name] == pkg) or (name in remote_list and pkg in remote_list[name]):
				continue
			print 'Removing %s ...' % pkg.fullname
			try_to_remove(pkg.fullname)
			no_files = False

		extraneous_files.sort()
		for elem in extraneous_files:
			print 'Warning: extraneous file %s' % elem

		if no_files:
			print 'No package files to remove'

		sys.exit()
	
	if operation in ['list-transient', 'list-outdated']:
		if operation == 'list-transient':
			print 'Transient packages:'
			valid_states = [slackroll_state_new, slackroll_state_unavailable, slackroll_state_outdated]
		else:
			print 'Outdated packages:'
			valid_states = [slackroll_state_outdated]
		names = [x for x in persistent_list if persistent_list[x] in valid_states]
		names.sort(cmp=pkg_cmp)
		glibc_affected = False
		for name in names:
			if slackroll_glibc_indicator in name:
				glibc_affected = True
			if operation == 'list-transient':
				print '    %s (%s)' % (name, slackroll_state_strings[persistent_list[name]])
			else:
				print '    %s' % name
		print 'End of list'
		if glibc_affected:
			print_glibc_warning()
		sys.exit()

	if operation == 'list-upgrades':
		print 'Available upgrades:'
		names = [x for x in local_list if persistent_list[x] == slackroll_state_outdated]
		names.sort(cmp=pkg_cmp)
		glibc_affected = False
		for name in names:
			candidates = not_pasture(remote_list[name])
			if len(candidates) == 0:
				print '    %s: Warning: only present in /pasture/\n' % name
				continue
			if slackroll_glibc_indicator in name:
				glibc_affected = True
			print '    %s:' % name
			print '\tLocal:\t%s' % local_list[name].idname
			for other in candidates:
				print '\tRemote:\t%s' % other.fullname
			print
		print 'End of list'
		if glibc_affected:
			print_glibc_warning()
		sys.exit()

	if operation == 'list-alternatives':
		print 'Packages with alternatives:'
		names = persistent_list.keys()
		names.sort(cmp=pkg_cmp)
		for name in names:
			versions = []
			if name in remote_list:
				versions.extend(remote_list[name])
			if name in local_list and local_list[name] not in versions:
				versions.append(local_list[name])
			if len(versions) > 1:
				print '    %s:' % name
				for ver in versions:
					print '\t%s' % ver.fullname
				print
		print 'End of list'
		sys.exit()

	if operation == 'list-new':
		print_in_states([slackroll_state_new], persistent_list, 'New packages:')

	if operation == 'list-unavailable':
		print_in_states([slackroll_state_unavailable], persistent_list, 'Unavailable packages:')

	if operation == 'list-installed':
		print_in_states([slackroll_state_installed], persistent_list, 'Installed packages:')

	if operation == 'list-not-installed':
		print_in_states([slackroll_state_notinstalled], persistent_list, 'Not installed packages:')

	if operation == 'list-frozen':
		print_in_states([slackroll_state_frozen], persistent_list, 'Frozen packages:')

	if operation == 'list-foreign':
		print_in_states([slackroll_state_foreign], persistent_list, 'Foreign packages:')
	
	if operation == 'list-local':
		print_keys(local_list, 'Local packages:')

	if operation == 'list-remote':
		print_keys(remote_list, 'Remote packages:')

	if operation == 'list-all':
		print_keys(persistent_list, 'All packages:')

	if operation == 'new-not-installed':
		from_states_to_state([slackroll_state_new], slackroll_state_notinstalled, persistent_list,
				[x for x in persistent_list.iterkeys() if persistent_list[x] == slackroll_state_new])

	if operation == 'unavailable-foreign':
		from_states_to_state([slackroll_state_unavailable], slackroll_state_foreign, persistent_list,
				[x for x in persistent_list.iterkeys() if persistent_list[x] == slackroll_state_unavailable])

	if operation == 'frozen':
		from_states_to_state([slackroll_state_frozen, slackroll_state_installed, slackroll_state_outdated],
				slackroll_state_frozen, persistent_list, sys.argv[2:])

	if operation == 'foreign':
		from_states_to_state([slackroll_state_foreign, slackroll_state_unavailable], slackroll_state_foreign, persistent_list, sys.argv[2:])
	
	if operation == 'not-installed':
		from_states_to_state([slackroll_state_notinstalled, slackroll_state_new], slackroll_state_notinstalled, persistent_list, sys.argv[2:])

	if operation == 'unavailable':
		from_states_to_state([slackroll_state_unavailable, slackroll_state_foreign], slackroll_state_unavailable, persistent_list, sys.argv[2:])

	if operation == 'new':
		from_states_to_state([slackroll_state_new, slackroll_state_notinstalled], slackroll_state_new, persistent_list, sys.argv[2:])

	if operation == 'installed':
		from_states_to_state([slackroll_state_installed, slackroll_state_frozen],
				slackroll_state_installed, persistent_list, sys.argv[2:], exit_flag=False)
		analyze_changes(local_list, remote_list, persistent_list) # Forced because it may need to be marked as outdated
		os.utime(slackroll_persistentlist_filename, None)
		sys.exit()

	if operation == 'list-versions':
		print 'Available versions:'
		for name in sys.argv[2:]:
			if name not in persistent_list:
				print '%s: unknown package' % name
				continue
			print '    %s:' % name
			if name in local_list:
				print '\tLocal:\t%s' % local_list[name].idname
			if name in remote_list:
				for ver in remote_list[name]:
					print '\tRemote:\t%s' % ver.fullname
			print
		print 'End of list'
		sys.exit()

	if operation in ['install', 'reinstall', 'download', 'info', 'urls']:
		install_operations_family(operation, sys.argv[2:], local_list, remote_list, persistent_list)
	
	if operation in ['install-new', 'download-new', 'info-new', 'urls-new']:
		names = [x for x in persistent_list if persistent_list[x] == slackroll_state_new]
		names.sort(cmp=pkg_cmp)
		if len(names) == 0:
			print 'No new packages'
			sys.exit()
		opname = operation.replace('-new', '')
		install_operations_family(opname, names, local_list, remote_list, persistent_list)

	if operation in ['remove', 'remove-unavailable']:
		if operation == 'remove':
			args = sys.argv[2:]
		else: # remove-unavailable
			args = [x for x in persistent_list if persistent_list[x] == slackroll_state_unavailable]
		if len(args) == 0:
			print 'No unavailable packages'
			sys.exit()
		for name in args:
			if name not in local_list:
				sys.exit('Error: %s not present in local system' % name)
			remove_pkg(local_list[name].idname)
		sys.exit()

	if operation == 'name-search':
		for retxt in sys.argv[2:]:
			results = False
			try:
				regexp = re.compile(retxt)
			except re.error:
				sys.exit('Error: invalid regular expression: %s' % retxt)
			print 'Searching for "%s":' % retxt
			names = [x for x in persistent_list if regexp.search(x) is not None]
			names.sort(cmp=pkg_cmp)
			if len(names) == 0:
				print '    (No results)\n'
				continue
			print ''.join(['    %s (%s)\n' % (x, slackroll_state_strings[persistent_list[x]]) for x in names])
		sys.exit()
	
	if operation == 'path-search':
		all_remotes = []
		for key in remote_list.iterkeys():
			all_remotes.extend(remote_list[key])
		for retxt in sys.argv[2:]:
			try:
				regexp = re.compile(retxt)
			except re.error:
				sys.exit('Error: invalid regular expression: %s' % retxt)
			print 'Searching for "%s":' % retxt
			matching_fullnames = [x.fullname for x in all_remotes if regexp.search(x.path) is not None]
			matching_fullnames.sort()
			if len(matching_fullnames) == 0:
				print '    (No results)\n'
				continue
			print ''.join(['    %s\n' % x for x in matching_fullnames])
		sys.exit()
	
except (KeyboardInterrupt, IOError), error:
	if isinstance(error, KeyboardInterrupt):
		sys.stderr.write('\nProgram aborted by user\n')
	else:
		sys.stderr.write('\nIOError: Broken pipe?\n')
	if persistent_list is not None:
		persistent_list.close()
	sys.exit(slackroll_exit_failure)

except IndexError:
	print_help()
	sys.exit(slackroll_exit_failure)
